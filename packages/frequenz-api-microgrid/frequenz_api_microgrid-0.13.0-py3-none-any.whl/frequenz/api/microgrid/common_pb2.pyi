"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Contains enums and messages reused throught the Microgrid API definitions.

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ErrorLevel:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ErrorLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ErrorLevel.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ERROR_LEVEL_UNSPECIFIED: _ErrorLevel.ValueType  # 0
    """Unspecified component error."""
    ERROR_LEVEL_WARN: _ErrorLevel.ValueType  # 1
    """Action must be taken to prevent a severe error from occurring in the
    future.
    """
    ERROR_LEVEL_CRITICAL: _ErrorLevel.ValueType  # 2
    """A severe error that causes the component to fail. Immediate action must be
    taken.
    """

class ErrorLevel(_ErrorLevel, metaclass=_ErrorLevelEnumTypeWrapper):
    """Error levels definitions."""

ERROR_LEVEL_UNSPECIFIED: ErrorLevel.ValueType  # 0
"""Unspecified component error."""
ERROR_LEVEL_WARN: ErrorLevel.ValueType  # 1
"""Action must be taken to prevent a severe error from occurring in the
future.
"""
ERROR_LEVEL_CRITICAL: ErrorLevel.ValueType  # 2
"""A severe error that causes the component to fail. Immediate action must be
taken.
"""
global___ErrorLevel = ErrorLevel

@typing_extensions.final
class Bounds(google.protobuf.message.Message):
    """A set of lower and upper bounds for any metric.
    The units of the bounds are always the same as the related metric.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOWER_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    lower: builtins.float
    """The lower bound."""
    upper: builtins.float
    """The upper bound."""
    def __init__(
        self,
        *,
        lower: builtins.float = ...,
        upper: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["lower", b"lower", "upper", b"upper"]) -> None: ...

global___Bounds = Bounds

@typing_extensions.final
class Metric(google.protobuf.message.Message):
    """A metric's value, with optional limits."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    RATED_BOUNDS_FIELD_NUMBER: builtins.int
    COMPONENT_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_EXCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_INCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    value: builtins.float
    """The current value of the metric."""
    @property
    def rated_bounds(self) -> global___Bounds:
        """The manufacturer's rated bounds of the metric. This may differ from
        `system_bounds` as it does not take into account the current state of the
        overall system.
        """
    @property
    def component_bounds(self) -> global___Bounds:
        """The current bounds of the metric, as imposed by the component this metric
        originates from.
        """
    @property
    def system_exclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are disallowed for the
        metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """
    @property
    def system_inclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are allowed for the metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraint `lower <= value <= upper`

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """
    def __init__(
        self,
        *,
        value: builtins.float = ...,
        rated_bounds: global___Bounds | None = ...,
        component_bounds: global___Bounds | None = ...,
        system_exclusion_bounds: global___Bounds | None = ...,
        system_inclusion_bounds: global___Bounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["component_bounds", b"component_bounds", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["component_bounds", b"component_bounds", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds", "value", b"value"]) -> None: ...

global___Metric = Metric

@typing_extensions.final
class MetricAggregation(google.protobuf.message.Message):
    """Metrics depicted as a collection of statistical summaries.

    Useful when a component has to report multiple values for the same metric.
    E.g., a battery is a collection of several blocks, and each block has a
    temperature sensor. The battery can report a summary of the values provided
    by all these sensors, like, min, max, avg, etc., and if possible, the entire
    array of temperature values.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AVG_FIELD_NUMBER: builtins.int
    MIN_FIELD_NUMBER: builtins.int
    MAX_FIELD_NUMBER: builtins.int
    RAW_VALUES_FIELD_NUMBER: builtins.int
    RATED_BOUNDS_FIELD_NUMBER: builtins.int
    COMPONENT_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_EXCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    SYSTEM_INCLUSION_BOUNDS_FIELD_NUMBER: builtins.int
    avg: builtins.float
    """The average value of the metric."""
    min: builtins.float
    """The minimum value of the metric."""
    max: builtins.float
    """The maximum value of the metric."""
    @property
    def raw_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The array of all the metric values."""
    @property
    def rated_bounds(self) -> global___Bounds:
        """The manufacturer's rated bounds of the metric. This may differ from
        `system_bounds` as it does not take into account the current state of the
        overall system.
        """
    @property
    def component_bounds(self) -> global___Bounds:
        """The current bounds of the metric, as imposed by the component this metric
        originates from.
        """
    @property
    def system_exclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are disallowed for the
        metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with power values
        that are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """
    @property
    def system_inclusion_bounds(self) -> global___Bounds:
        """These bounds indicate the range of values that are allowed for the metric.
        If these bounds for a metric are [`lower`, `upper`], then this metric's
        `value` needs to comply with the constraint `lower <= value <= upper`

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with power values
        that are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """
    def __init__(
        self,
        *,
        avg: builtins.float = ...,
        min: builtins.float | None = ...,
        max: builtins.float | None = ...,
        raw_values: collections.abc.Iterable[builtins.float] | None = ...,
        rated_bounds: global___Bounds | None = ...,
        component_bounds: global___Bounds | None = ...,
        system_exclusion_bounds: global___Bounds | None = ...,
        system_inclusion_bounds: global___Bounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_max", b"_max", "_min", b"_min", "component_bounds", b"component_bounds", "max", b"max", "min", b"min", "rated_bounds", b"rated_bounds", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_max", b"_max", "_min", b"_min", "avg", b"avg", "component_bounds", b"component_bounds", "max", b"max", "min", b"min", "rated_bounds", b"rated_bounds", "raw_values", b"raw_values", "system_exclusion_bounds", b"system_exclusion_bounds", "system_inclusion_bounds", b"system_inclusion_bounds"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_max", b"_max"]) -> typing_extensions.Literal["max"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_min", b"_min"]) -> typing_extensions.Literal["min"] | None: ...

global___MetricAggregation = MetricAggregation

@typing_extensions.final
class DC(google.protobuf.message.Message):
    """Metrics of a DC electrical connection."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VOLTAGE_FIELD_NUMBER: builtins.int
    CURRENT_FIELD_NUMBER: builtins.int
    POWER_FIELD_NUMBER: builtins.int
    @property
    def voltage(self) -> global___Metric:
        """The DC voltage across the component.
        In Volt (V).
        """
    @property
    def current(self) -> global___Metric:
        """The DC current flowing away from the grid connection.
        In passive sign convention:
        +ve current means consumption, away from the grid.
        -ve current means supply into the grid.
        In Ampere (A).
        """
    @property
    def power(self) -> global___Metric:
        """The DC power flowing away from the grid connection.
        In passive sign convention:
        +ve power means consumption, away from the grid.
        -ve power means supply into the grid.
        In Watt (W).
        """
    def __init__(
        self,
        *,
        voltage: global___Metric | None = ...,
        current: global___Metric | None = ...,
        power: global___Metric | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["current", b"current", "power", b"power", "voltage", b"voltage"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["current", b"current", "power", b"power", "voltage", b"voltage"]) -> None: ...

global___DC = DC

@typing_extensions.final
class AC(google.protobuf.message.Message):
    """The current state and metrics of the electrical connections to the
    inverter.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ActiveEnergy(google.protobuf.message.Message):
        """The active energy the inverter is consuming or generating."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENERGY_FIELD_NUMBER: builtins.int
        ENERGY_CONSUMED_FIELD_NUMBER: builtins.int
        ENERGY_DELIVERED_FIELD_NUMBER: builtins.int
        @property
        def energy(self) -> global___Metric:
            """The sum of the consumed and delivered energy.
            This is a signed value in passive sign convention: if more energy is
            consumed than delivered, this is a -ve number, otherwise +ve.
            In Watt-hour (Wh).
            """
        @property
        def energy_consumed(self) -> global___Metric:
            """The consumed energy.
            In Watt-hour (Wh).
            """
        @property
        def energy_delivered(self) -> global___Metric:
            """The delivered energy.
            In Watt-hour (Wh).
            """
        def __init__(
            self,
            *,
            energy: global___Metric | None = ...,
            energy_consumed: global___Metric | None = ...,
            energy_delivered: global___Metric | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["energy", b"energy", "energy_consumed", b"energy_consumed", "energy_delivered", b"energy_delivered"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["energy", b"energy", "energy_consumed", b"energy_consumed", "energy_delivered", b"energy_delivered"]) -> None: ...

    @typing_extensions.final
    class ReactiveEnergy(google.protobuf.message.Message):
        """The reactive energy the inverter is consuming or generating."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENERGY_FIELD_NUMBER: builtins.int
        ENERGY_CAPACITIVE_FIELD_NUMBER: builtins.int
        ENERGY_INDUCTIVE_FIELD_NUMBER: builtins.int
        @property
        def energy(self) -> global___Metric:
            """The sum of the capacitive and inductive energy.
            This is a signed value. If more energy is capacitive than inductive,
            this is a -ve number, otherwise +ve.
            In Volt-Ampere-hour (VArh).
            """
        @property
        def energy_capacitive(self) -> global___Metric:
            """The capacitive energy.
            In Volt-Ampere-hour (VArh).
            """
        @property
        def energy_inductive(self) -> global___Metric:
            """The inductive energy.
            In Volt-Ampere-hour (VArh).
            """
        def __init__(
            self,
            *,
            energy: global___Metric | None = ...,
            energy_capacitive: global___Metric | None = ...,
            energy_inductive: global___Metric | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["energy", b"energy", "energy_capacitive", b"energy_capacitive", "energy_inductive", b"energy_inductive"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["energy", b"energy", "energy_capacitive", b"energy_capacitive", "energy_inductive", b"energy_inductive"]) -> None: ...

    @typing_extensions.final
    class Harmonics(google.protobuf.message.Message):
        """The harmonics of the fast Fourier transform of the instantaneous values
        and its total harmonic distortion.
        In percent (%).
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        HARMONIC_1_FIELD_NUMBER: builtins.int
        HARMONIC_2_FIELD_NUMBER: builtins.int
        HARMONIC_3_FIELD_NUMBER: builtins.int
        HARMONIC_4_FIELD_NUMBER: builtins.int
        HARMONIC_5_FIELD_NUMBER: builtins.int
        HARMONIC_6_FIELD_NUMBER: builtins.int
        HARMONIC_7_FIELD_NUMBER: builtins.int
        HARMONIC_8_FIELD_NUMBER: builtins.int
        HARMONIC_9_FIELD_NUMBER: builtins.int
        HARMONIC_10_FIELD_NUMBER: builtins.int
        HARMONIC_11_FIELD_NUMBER: builtins.int
        harmonic_1: builtins.float
        harmonic_2: builtins.float
        harmonic_3: builtins.float
        harmonic_4: builtins.float
        harmonic_5: builtins.float
        harmonic_6: builtins.float
        harmonic_7: builtins.float
        harmonic_8: builtins.float
        harmonic_9: builtins.float
        harmonic_10: builtins.float
        harmonic_11: builtins.float
        def __init__(
            self,
            *,
            harmonic_1: builtins.float = ...,
            harmonic_2: builtins.float = ...,
            harmonic_3: builtins.float = ...,
            harmonic_4: builtins.float = ...,
            harmonic_5: builtins.float = ...,
            harmonic_6: builtins.float = ...,
            harmonic_7: builtins.float = ...,
            harmonic_8: builtins.float = ...,
            harmonic_9: builtins.float = ...,
            harmonic_10: builtins.float = ...,
            harmonic_11: builtins.float = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["harmonic_1", b"harmonic_1", "harmonic_10", b"harmonic_10", "harmonic_11", b"harmonic_11", "harmonic_2", b"harmonic_2", "harmonic_3", b"harmonic_3", "harmonic_4", b"harmonic_4", "harmonic_5", b"harmonic_5", "harmonic_6", b"harmonic_6", "harmonic_7", b"harmonic_7", "harmonic_8", b"harmonic_8", "harmonic_9", b"harmonic_9"]) -> None: ...

    @typing_extensions.final
    class ACPhase(google.protobuf.message.Message):
        """AC metrics of a single phase."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        VOLTAGE_FIELD_NUMBER: builtins.int
        CURRENT_FIELD_NUMBER: builtins.int
        POWER_ACTIVE_FIELD_NUMBER: builtins.int
        POWER_REACTIVE_FIELD_NUMBER: builtins.int
        ENERGY_APPARENT_FIELD_NUMBER: builtins.int
        ENERGY_ACTIVE_FIELD_NUMBER: builtins.int
        ENERGY_REACTIVE_FIELD_NUMBER: builtins.int
        HARMONICS_POWER_ACTIVE_FIELD_NUMBER: builtins.int
        THD_POWER_ACTIVE_FIELD_NUMBER: builtins.int
        @property
        def voltage(self) -> global___Metric:
            """The AC voltage between the line and the neutral wire.
            In Volt (V).
            """
        @property
        def current(self) -> global___Metric:
            """AC current.
            +ve current means consumption, away from the grid.
            -ve current means supply into the grid.
            In Ampere (A).
            """
        @property
        def power_active(self) -> global___Metric:
            """AC active power.
            +ve power means consumption, away from the grid.
            -ve power means supply into the grid.
            In Watt (W).
            """
        @property
        def power_reactive(self) -> global___Metric:
            """AC reactive power.
            +ve power means inductive (leading).
            -ve power means capacitive (lagging).
            In Volt-Ampere reactive (VAr).
            """
        @property
        def energy_apparent(self) -> global___Metric:
            """The total apparent energy. A Positive value represents the net apparent
            energy supplied to the grid connection, and vice versa.
            In Volt-Ampere-hour (VAh).
            """
        @property
        def energy_active(self) -> global___AC.ActiveEnergy:
            """The total active energy counters for the underlying component's
            consumption and supply.
            In Watt-hour (Wh).
            """
        @property
        def energy_reactive(self) -> global___AC.ReactiveEnergy:
            """The total reactive energy counters for the underlying component's
            capacitive and inductive energy values.
            In Volt-Ampere reactive hour (VArh).
            """
        @property
        def harmonics_power_active(self) -> global___AC.Harmonics:
            """Harmonics of the instantaneous active power at the component.
            In percent (%).
            """
        thd_power_active: builtins.float
        """Total harmonic distortion
        of the instantaneous active power at the component.
        In percent (%).
        """
        def __init__(
            self,
            *,
            voltage: global___Metric | None = ...,
            current: global___Metric | None = ...,
            power_active: global___Metric | None = ...,
            power_reactive: global___Metric | None = ...,
            energy_apparent: global___Metric | None = ...,
            energy_active: global___AC.ActiveEnergy | None = ...,
            energy_reactive: global___AC.ReactiveEnergy | None = ...,
            harmonics_power_active: global___AC.Harmonics | None = ...,
            thd_power_active: builtins.float = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["current", b"current", "energy_active", b"energy_active", "energy_apparent", b"energy_apparent", "energy_reactive", b"energy_reactive", "harmonics_power_active", b"harmonics_power_active", "power_active", b"power_active", "power_reactive", b"power_reactive", "voltage", b"voltage"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["current", b"current", "energy_active", b"energy_active", "energy_apparent", b"energy_apparent", "energy_reactive", b"energy_reactive", "harmonics_power_active", b"harmonics_power_active", "power_active", b"power_active", "power_reactive", b"power_reactive", "thd_power_active", b"thd_power_active", "voltage", b"voltage"]) -> None: ...

    FREQUENCY_FIELD_NUMBER: builtins.int
    CURRENT_FIELD_NUMBER: builtins.int
    POWER_APPARENT_FIELD_NUMBER: builtins.int
    POWER_ACTIVE_FIELD_NUMBER: builtins.int
    POWER_REACTIVE_FIELD_NUMBER: builtins.int
    ENERGY_APPARENT_FIELD_NUMBER: builtins.int
    ENERGY_ACTIVE_FIELD_NUMBER: builtins.int
    ENERGY_REACTIVE_FIELD_NUMBER: builtins.int
    HARMONICS_POWER_ACTIVE_FIELD_NUMBER: builtins.int
    THD_POWER_ACTIVE_FIELD_NUMBER: builtins.int
    PHASE_1_FIELD_NUMBER: builtins.int
    PHASE_2_FIELD_NUMBER: builtins.int
    PHASE_3_FIELD_NUMBER: builtins.int
    @property
    def frequency(self) -> global___Metric:
        """Overall AC metrics.

        The AC frequency.
        In Hertz (Hz).
        """
    @property
    def current(self) -> global___Metric:
        """The apparent 3-phase AC current. Positive values represent apparent energy
        flowing towards the grid connection, and vice versa.
        In Ampere (A).
        """
    @property
    def power_apparent(self) -> global___Metric:
        """The apparent 3-phase AC power. Positive values represent apparent energy
        flowing towards the grid connection, and vice versa.
        In Volt-Ampere (VA).
        """
    @property
    def power_active(self) -> global___Metric:
        """The total active 3-phase AC active power.
        +ve power means consumption, away from the grid.
        -ve power means supply into the grid.
        In Watt (W).
        """
    @property
    def power_reactive(self) -> global___Metric:
        """The reactive 3-phase AC power.
        +ve power means inductive (leading).
        -ve power means capacitive (lagging).
        In Volt-Ampere reactive (VAr).
        """
    @property
    def energy_apparent(self) -> global___Metric:
        """The total 3-phase apparent energy. A positive value represents the net
        apparent energy supplied to the grid connection, and vice versa.
        In Volt-Ampere-hour (VAh).
        """
    @property
    def energy_active(self) -> global___AC.ActiveEnergy:
        """The total 3-phase active energy counters for the underlying component's
        consumption and supply.
        In Watt-hour (Wh).
        """
    @property
    def energy_reactive(self) -> global___AC.ReactiveEnergy:
        """The total 3-phase reactive energy counters for the underlying component's
        capacitive and inductive energy values.
        In Volt-Ampere reactive hour (VArh).
        FIXME: ReactiveEnergy says Volt-Ampere-hour (VAh).
        """
    @property
    def harmonics_power_active(self) -> global___AC.Harmonics:
        """The sums of the harmonics
        of the instantaneous active power at the component across all 3 phases.
        """
    thd_power_active: builtins.float
    """The sums of the total harmonic distortion
    of the instantaneous active power at the component across all 3 phases.
    """
    @property
    def phase_1(self) -> global___AC.ACPhase:
        """AC metrics for phase/line 1."""
    @property
    def phase_2(self) -> global___AC.ACPhase:
        """AC metrics for phase/line 2."""
    @property
    def phase_3(self) -> global___AC.ACPhase:
        """AC metrics for phase/line 3."""
    def __init__(
        self,
        *,
        frequency: global___Metric | None = ...,
        current: global___Metric | None = ...,
        power_apparent: global___Metric | None = ...,
        power_active: global___Metric | None = ...,
        power_reactive: global___Metric | None = ...,
        energy_apparent: global___Metric | None = ...,
        energy_active: global___AC.ActiveEnergy | None = ...,
        energy_reactive: global___AC.ReactiveEnergy | None = ...,
        harmonics_power_active: global___AC.Harmonics | None = ...,
        thd_power_active: builtins.float = ...,
        phase_1: global___AC.ACPhase | None = ...,
        phase_2: global___AC.ACPhase | None = ...,
        phase_3: global___AC.ACPhase | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["current", b"current", "energy_active", b"energy_active", "energy_apparent", b"energy_apparent", "energy_reactive", b"energy_reactive", "frequency", b"frequency", "harmonics_power_active", b"harmonics_power_active", "phase_1", b"phase_1", "phase_2", b"phase_2", "phase_3", b"phase_3", "power_active", b"power_active", "power_apparent", b"power_apparent", "power_reactive", b"power_reactive"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["current", b"current", "energy_active", b"energy_active", "energy_apparent", b"energy_apparent", "energy_reactive", b"energy_reactive", "frequency", b"frequency", "harmonics_power_active", b"harmonics_power_active", "phase_1", b"phase_1", "phase_2", b"phase_2", "phase_3", b"phase_3", "power_active", b"power_active", "power_apparent", b"power_apparent", "power_reactive", b"power_reactive", "thd_power_active", b"thd_power_active"]) -> None: ...

global___AC = AC
