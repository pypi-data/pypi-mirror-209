#!/usr/bin/env python
# -*- coding: utf-8 -*-
# =============================================================================
# File: buildutils.py
# Author: Brandon Alba <brandonealba@protonmail.com>
# License: Published under MIT license
# =============================================================================
'''
Miscellaneous tools for assising in the generation of generating build scripts,
including string manipulation, path expansion, etc. Written to be used in
conjunction with the ninja_syntax library to create build.ninja files.
'''

# =============================================================================
# IMPORTS
# =============================================================================

import os
import fnmatch
from .thirdparty import ninja_syntax
import inspect

# =============================================================================
# GLOBAL VARIABLES
# =============================================================================

# =============================================================================
# FUNCTION DEFINITIONS
# =============================================================================

def list_to_str ( list_in:list, prefix:str='')->str:
    '''
    Takes a list as input and outputs that list as single string, with each
    former array element separated from another by spaces.
    '''
    
    out = ''
    for i, item in enumerate(list_in):
        out += (str(prefix + item).rstrip().lstrip()) 
        if i != len(list_in) - 1: out += ' '

    return out

def fdir_index_recursive ( ext, initialdir, return_dir=False )->list:
    '''
    Recursively searches a directory tree starting from a given initial directory and
    creates a list of paths to all files found matching a given extension. Pass the extension
    in the form of a wildcard, i.e., '*.c'. Alternatively returns instead a list of directories
    where matching files were found.
    '''

    out = []
    
    for root, dirs, files in os.walk(initialdir):
        for fname in fnmatch.filter(files, ext):
            if return_dir:
                if not root in out: out.append(root)
            else:
                out.append(os.path.join(root, fname))

    return out

def src_to_obj ( srcs:list, builddir, obj_ext='.o')->list:

    src_fnames = [os.path.basename(src) for src in srcs]
    obj_fnames = [src_fname + obj_ext for src_fname in src_fnames]
    obj_paths = [os.path.join(builddir, obj_fname) for obj_fname in obj_fnames]

    return obj_paths


def build_multiple ( writer:ninja_syntax.Writer, outputs, rule, inputs:list, implicit=None, order_only=None,
          variables=None, implicit_outputs=None, pool=None, dyndep=None):
    '''
    Writes multiple separate build statements for one-source -> one output style builds.
    Useful for cases like compiling multiple C source files from a list. Requires that
    the length of outputs match the length of inputs.
    '''
    
    assert len(outputs) == len(inputs)

    for i, inp in enumerate(inputs):
        writer.build(
                outputs[i],
                rule,
                inp,
                implicit,
                order_only,
                variables,
                implicit_outputs,
                pool,
                dyndep)

    return outputs

def wr_init ( fdir:str, greeter:str='' )->ninja_syntax.Writer:
    '''
    Simple function for initializing a build.ninja writer. By default, adds a comment
    to the top of the file indicating the caller and a warning about editing, but provides
    an optional arg to override this message.
    '''

    caller_fname = (os.path.basename(inspect.stack()[1].filename))
    
    f_build = open(os.path.join(fdir, 'build.ninja'),'w')
    wr = ninja_syntax.Writer(f_build)

    if greeter:
        wr.comment(greeter)
    else:
        wr.comment(f'Generated by {caller_fname}. Do not edit directly!')
    wr.newline()

    return wr

def wr_cc_rule ( writer:ninja_syntax.Writer ):    
    writer.rule(
            'cc',
            list_to_str(['$cc', '-MD -MF $out.d', '$ccflags', '$ccdefs', '$cincs', '-c', '$in', '-o', '$out']), 
            'Compiling C file $in...',
            depfile='$out.d')
    writer.newline()

def wr_cpp_rule ( writer:ninja_syntax.Writer ):
    writer.rule(
            'cpp',
            list_to_str(['$cxx', '-MD -MF $out.d', '$cppflags', '$cppdefines', '$cppincs', '-c', '$in', '-o', '$out']), 
            'Compiling C++ file $in...',
            depfile='$out.d')
    writer.newline()

def wr_asm_rule ( writer:ninja_syntax.Writer ):
    writer.rule(
            'as', 
            list_to_str(['$asm', '$ccflags', '$cincs', '-c', '$in', '-o', '$out']), 
            'Compiling ASM file $in...')
    writer.newline()

def wr_ld_rule ( writer:ninja_syntax.Writer ):
    writer.rule(
            'ld',
            list_to_str(['$cc', '$in', '$ldflags', '$flag_opt', '-o', '$out']),
            'Linking object files...')
    writer.newline()

def wr_var_nl ( writer:ninja_syntax.Writer, key:str, value:str, indent:int=0 ):
    '''
    Wrapper for ninja_syntax.Writer().variable() that adds a newline after the declaration.
    '''
    writer.variable(key, value, indent)
    writer.newline()

def gen_ccls ( inc_list=[], def_list=[], cflags=[],
        cppflags=[], root='.', extra_dirs=[] ):
    '''
    Generates a CCLS file based on a list of includes. Currently not very clever, but
    accepts generic directories in the form of a list of strings so it can be used for
    any potential CCLS file.
    '''

    with open ( os.path.join(root, '.ccls'), 'w' ) as f:
        f.write('clang\n')
        for directive in extra_dirs:
            f.write(str(directive) + '\n')
        if cflags:
            f.write('%c')
            for flag in cflags:
                f.write(' ' + flag)
            f.write('\n')
        if cppflags:
            f.write('%cpp')
            for flag in cppflags:
                f.write(' ' + flag)
            f.write('\n')
        for define in def_list:
            f.write(f'-D{define}\n')
        for inc in inc_list:
            f.write(f'-I{inc}\n')
