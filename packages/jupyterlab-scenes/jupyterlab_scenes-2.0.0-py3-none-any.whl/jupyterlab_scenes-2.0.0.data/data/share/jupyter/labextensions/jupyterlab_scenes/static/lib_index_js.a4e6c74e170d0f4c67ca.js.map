{"version":3,"file":"lib_index_js.a4e6c74e170d0f4c67ca.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAuD;AACV;AACG;AACL;AAC3C;AACA;AACO;AACP;AACA,iCAAiC,qDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gCAAgC;AACjF,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,0CAA0C;AACjK,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAgB,uCAAuC,iEAAiE;AAC5I;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,8EAA4B;AACpC,iDAAiD,4DAA4D;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA,oBAAoB,0DAAmB;AACvC,gBAAgB,0DAAmB,CAAC,sDAAa,IAAI,+OAA+O;AACpS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA;AACA,gBAAgB,qEAAmB,GAAG,iCAAiC;AACvE;AACA;AACA;AACA,wBAAwB,sEAAgB;AACxC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,qEAAmB,GAAG,wCAAwC;AAC9E;AACA;AACA;AACA,wBAAwB,sEAAgB;AACxC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0CAA0C,wDAAM;AAChD;AACA,8BAA8B,qEAAmB,IAAI,iEAAe,GAAG,iBAAiB;AACxF,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,qEAAmB,GAAG,kDAAkD;AACxF;AACA;AACA;AACA,wBAAwB,sEAAgB;AACxC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,iDAAI,GAAG,8BAA8B;AACpE;AACA,mCAAmC,qDAAqD;AACxF,mCAAmC,6CAA6C;AAChF,mCAAmC,mBAAmB;AACtD,mCAAmC,mDAAmD;AACtF,mCAAmC,mDAAmD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACzB","sources":["webpack://jupyterlab_scenes/./lib/backend.js","webpack://jupyterlab_scenes/./lib/components.js","webpack://jupyterlab_scenes/./lib/index.js","webpack://jupyterlab_scenes/./lib/widget.js"],"sourcesContent":["import { NotebookActions } from '@jupyterlab/notebook';\nimport { CodeCell } from '@jupyterlab/cells';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { Signal } from '@lumino/signaling';\nconst NB_METADATA_KEY = 'scenes_data';\nconst SCENE_CELL_CLASS = 'scene-cell';\nexport class NotebookHandler {\n    constructor(nbTracker, settingRegistry) {\n        this.scenesChanged = new Signal(this);\n        /* ****************************************************************************************************************************************\n         * Handle kernel (re-)starts\n         * ****************************************************************************************************************************************/\n        this._kernelStatusDict = {};\n        this._nbTracker = nbTracker;\n        this._sceneDB = new NotebookSceneDatabase(nbTracker);\n        this._enableLegacyInits = false;\n        // load settings\n        if (settingRegistry) {\n            settingRegistry.load('jupyterlab_scenes:plugin').then(settings => {\n                this.updateSettings(settings);\n                settings.changed.connect(() => { this.updateSettings(settings); });\n            })\n                .catch(reason => {\n                console.error('Failed to load settings for jupyterlab_scenes.', reason);\n            });\n        }\n        this._setupKernelListener();\n    }\n    updateSettings(settings) {\n        this._enableLegacyInits = settings.composite.legacyInit;\n    }\n    _setupKernelListener() {\n        this._nbTracker.widgetAdded.connect(async (sender, nbPanel) => {\n            nbPanel.context.sessionContext.ready.then(() => {\n                this._kernelStatusDict[nbPanel.context.sessionContext.session.kernel.id] = 'connecting';\n                nbPanel.context.sessionContext.session.kernel.connectionStatusChanged.connect((kernel, conn_stat) => { this._kernelListener(kernel, conn_stat); });\n            });\n        });\n    }\n    _kernelListener(kernel, conn_stat) {\n        if (conn_stat == 'connecting') {\n            this._kernelStatusDict[kernel.id] = 'connecting';\n        }\n        else if (conn_stat == 'connected') {\n            if (this._kernelStatusDict[kernel.id] == 'connecting') {\n                let notebookPanelList = [];\n                this._nbTracker.forEach((nbPanel) => {\n                    if (nbPanel.context.sessionContext.session.kernel.id == kernel.id) {\n                        notebookPanelList.push(nbPanel);\n                    }\n                });\n                if (notebookPanelList.length > 0) {\n                    let init_scene = this._sceneDB.getInitScene();\n                    if (init_scene)\n                        this.runSceneInNotebook(notebookPanelList[0], init_scene);\n                }\n            }\n            delete this._kernelStatusDict[kernel.id];\n        }\n    }\n    /* ****************************************************************************************************************************************\n     * Functionality provided to the main widget\n     * ****************************************************************************************************************************************/\n    // **** simple scene getters *************************************************\n    getNotebookTitle() {\n        return this._sceneDB.getNotebookTitle();\n    }\n    getScenesList() {\n        return this._sceneDB.getScenesList();\n    }\n    getActiveScene(notebook = null) {\n        return this._sceneDB.getActiveScene(notebook);\n    }\n    getInitScene() {\n        return this._sceneDB.getInitScene();\n    }\n    // **** scene setters ********************************************************\n    toggleInitScene(scene_name) {\n        this._sceneDB.toggleInitScene(scene_name);\n        this._scenesChanged();\n    }\n    setActiveScene(scene_name) {\n        this._sceneDB.setActiveScene(scene_name);\n        this._scenesChanged();\n    }\n    renameScene(old_scene_name, new_scene_name) {\n        const scenes_list = this.getScenesList();\n        if (scenes_list.includes(new_scene_name))\n            return 'fail';\n        if (this._sceneDB.getInitScene() == old_scene_name) {\n            this._sceneDB.toggleInitScene(new_scene_name);\n        }\n        if (this._sceneDB.getActiveScene() == old_scene_name) {\n            this._sceneDB.setActiveScene(new_scene_name);\n        }\n        let idx = scenes_list.lastIndexOf(old_scene_name);\n        scenes_list[idx] = new_scene_name;\n        this._sceneDB.setScenesList(scenes_list);\n        this._renameSceneTagFromAllCells(this._nbTracker.currentWidget, old_scene_name, new_scene_name);\n        this._scenesChanged();\n        return 'success';\n    }\n    deleteScene(scene_name) {\n        let scenes_list = this._sceneDB.getScenesList();\n        if (scenes_list.length == 1)\n            return;\n        if (this._sceneDB.getInitScene() == scene_name) {\n            this._sceneDB.toggleInitScene(scene_name);\n        }\n        let resetActiveScene = this._sceneDB.getActiveScene() == scene_name;\n        this._removeSceneTagFromAllCells(this._nbTracker.currentWidget, scene_name);\n        let idx = scenes_list.lastIndexOf(scene_name);\n        scenes_list.splice(idx, 1);\n        this._sceneDB.setScenesList(scenes_list);\n        if (resetActiveScene) {\n            if (idx < scenes_list.length) {\n                this.setActiveScene(scenes_list[idx]);\n            }\n            else {\n                this.setActiveScene(scenes_list[idx - 1]);\n            }\n        }\n        this._scenesChanged();\n    }\n    toggleSceneMembershipOfSelectedCells() {\n        if (!this._nbTracker.currentWidget)\n            return;\n        if (!this._nbTracker.activeCell)\n            return;\n        const current_scene = this._sceneDB.getActiveScene();\n        const is_init_scene = current_scene == this.getInitScene();\n        const tag = 'scene__' + current_scene;\n        const notebook = this._nbTracker.currentWidget.content;\n        const set_membership = !this._nbTracker.activeCell.model.getMetadata(tag);\n        //const set_membership = !this._nbTracker.activeCell.model.getMetadata(tag);\n        notebook.widgets.forEach((cell) => {\n            if (!notebook.isSelectedOrActive(cell))\n                return;\n            if (cell.model.type != 'code')\n                return;\n            if (set_membership) {\n                cell.model.setMetadata(tag, true);\n                if (is_init_scene) {\n                    cell.model.setMetadata('init_cell', true);\n                }\n            }\n            else {\n                cell.model.deleteMetadata(tag);\n                if (is_init_scene) {\n                    cell.model.deleteMetadata('init_cell');\n                }\n            }\n            this._updateCellClassAndTags(cell, tag);\n        });\n    }\n    // **** scene management and running *****************************************\n    runActiveSceneInCurrentNotebook() {\n        const active_scene = this._sceneDB.getActiveScene();\n        if (active_scene)\n            this.runSceneInCurrentNotebook(active_scene);\n    }\n    runSceneInCurrentNotebook(scene_name) {\n        if (!this._nbTracker.currentWidget)\n            return;\n        const notebookPanel = this._nbTracker.currentWidget;\n        this.runSceneInNotebook(notebookPanel, scene_name);\n    }\n    runSceneInNotebook(notebookPanel, scene_name) {\n        const tag = this._getSceneTag(scene_name);\n        notebookPanel.content.widgets.map((cell) => {\n            if (!!cell.model.getMetadata(tag)) {\n                if (cell.model.type == 'code') {\n                    CodeCell.execute(cell, notebookPanel.sessionContext, { recordTiming: notebookPanel.content.notebookConfig.recordTiming });\n                }\n            }\n        });\n    }\n    createNewEmptyScene(scene_name) {\n        const scene_list = this.getScenesList();\n        if (scene_list.includes(scene_name))\n            return 'fail';\n        scene_list.push(scene_name);\n        this._sceneDB.setScenesList(scene_list);\n        this._sceneDB.setActiveScene(scene_name);\n        this._scenesChanged();\n        return 'success';\n    }\n    duplicateActiveScene(new_scene_name) {\n        let retval = this.createNewEmptyScene(new_scene_name);\n        if (retval == 'fail')\n            return 'fail';\n        this._duplicateSceneTagInAllCells(this._nbTracker.currentWidget, this.getActiveScene(), new_scene_name);\n        this._sceneDB.setActiveScene(new_scene_name);\n        this._scenesChanged();\n        return retval;\n    }\n    moveActiveSceneUp() {\n        this._moveScene(this._sceneDB.getActiveScene(), 'up');\n        this._scenesChanged();\n    }\n    moveActiveSceneDown() {\n        this._moveScene(this._sceneDB.getActiveScene(), 'down');\n        this._scenesChanged();\n    }\n    // **** various **************************************************************\n    updateCellClassesAndTags(notebook, scene_name = null, cell = null) {\n        // console.log('updating', scene_name)\n        if (scene_name == null)\n            scene_name = this.getActiveScene();\n        const scene_tag = this._getSceneTag(scene_name);\n        if (cell == null) {\n            notebook.widgets.map((cell) => {\n                this._updateCellClassAndTags(cell, scene_tag);\n            });\n        }\n        else {\n            this._updateCellClassAndTags(cell, scene_tag);\n        }\n    }\n    jumpToNextSceneCell() {\n        const presentCell = this._nbTracker.activeCell;\n        if (!presentCell)\n            return;\n        const tag = this._getSceneTag(this.getActiveScene());\n        const cells = this._nbTracker.currentWidget.content.widgets;\n        let cellIdx = cells.indexOf(presentCell);\n        let numCells = cells.length;\n        for (let n = cellIdx + 1; n < numCells; n++) {\n            let cell = cells[n];\n            if (cell.model.getMetadata(tag)) {\n                this._activateCellAndExpandParentHeadings(cell);\n                break;\n            }\n        }\n    }\n    jumpToPreviousSceneCell() {\n        const presentCell = this._nbTracker.activeCell;\n        if (!presentCell)\n            return;\n        const tag = this._getSceneTag(this.getActiveScene());\n        const cells = this._nbTracker.currentWidget.content.widgets;\n        let cellIdx = cells.indexOf(presentCell);\n        for (let n = cellIdx - 1; n >= 0; n--) {\n            let cell = cells[n];\n            if (cell.model.getMetadata(tag)) {\n                this._activateCellAndExpandParentHeadings(cell);\n                break;\n            }\n        }\n    }\n    importLegacyInitializationCells(notebook) {\n        if (!this._enableLegacyInits)\n            return;\n        let init_scenes_consistent = true;\n        let legacy_init_cells_exist = false;\n        let init_scene = this.getInitScene();\n        let init_scene_tag = (init_scene != null) ? this._getSceneTag(init_scene) : null;\n        // find out if there are legacy init cells and, if so, whether they are consistent with the scenes init cell\n        notebook.widgets.map((cell) => {\n            let is_legacy_init_cell = !!cell.model.getMetadata('init_cell');\n            let is_scenes_init_cell = init_scene_tag != null && !!cell.model.getMetadata(init_scene_tag);\n            if (is_legacy_init_cell) {\n                legacy_init_cells_exist = true;\n            }\n            if (is_legacy_init_cell != is_scenes_init_cell) {\n                init_scenes_consistent = false;\n            }\n        });\n        if (!init_scenes_consistent && legacy_init_cells_exist) {\n            const scene_name = 'Legacy Init';\n            notebook.widgets.map((cell) => {\n                let is_legacy_init_cell = !!cell.model.getMetadata('init_cell');\n                if (is_legacy_init_cell) {\n                    cell.model.setMetadata(this._getSceneTag(scene_name), true);\n                }\n            });\n            const scene_list = this.getScenesList();\n            if (!scene_list.includes(scene_name)) {\n                scene_list.push(scene_name);\n                this._sceneDB.setScenesList(scene_list);\n            }\n            this.toggleInitScene(scene_name);\n            this.setActiveScene(scene_name);\n        }\n    }\n    /* ****************************************************************************************************************************************\n     * Various private helper methods\n     * ****************************************************************************************************************************************/\n    _updateCellClassAndTags(cell, scene_tag) {\n        let cell_tags = [];\n        if (cell.model.getMetadata('tags')) {\n            cell_tags = cell.model.getMetadata('tags');\n        }\n        if (!!cell.model.getMetadata(scene_tag)) {\n            cell.addClass(SCENE_CELL_CLASS);\n            if (!cell_tags.includes('ActiveScene'))\n                cell_tags.push('ActiveScene');\n        }\n        else {\n            cell.removeClass(SCENE_CELL_CLASS);\n            if (cell_tags.includes('ActiveScene'))\n                cell_tags.splice(cell_tags.indexOf('ActiveScene'), 1);\n        }\n        if (cell_tags.length > 0) {\n            cell.model.setMetadata(\"tags\", cell_tags);\n        }\n        else {\n            cell.model.deleteMetadata(\"tags\");\n        }\n    }\n    _writeCellMetadataForLegacyInitializationCellsPlugin(notebook) {\n        if (!this._enableLegacyInits)\n            return;\n        let init_scene = this.getInitScene();\n        let init_scene_tag = (init_scene != null) ? this._getSceneTag(init_scene) : null;\n        notebook.widgets.map((cell) => {\n            if (init_scene_tag != null && !!cell.model.getMetadata(init_scene_tag)) {\n                cell.model.setMetadata('init_cell', true);\n            }\n            else {\n                cell.model.deleteMetadata('init_cell');\n            }\n        });\n    }\n    _activateCellAndExpandParentHeadings(cell) {\n        let notebook = this._nbTracker.currentWidget.content;\n        NotebookActions.expandParent(cell, notebook);\n        notebook.scrollToCell(cell).then(() => { notebook.activeCellIndex = notebook.widgets.indexOf(cell); });\n    }\n    _moveScene(scene_name, direction) {\n        const scenes_list = this.getScenesList();\n        let idx = scenes_list.indexOf(scene_name);\n        if (direction == 'down') {\n            if (idx == scenes_list.length - 1)\n                return;\n        }\n        else { // direction = 'up'\n            if (idx == 0)\n                return;\n            idx -= 1;\n        }\n        scenes_list.splice(idx, 2, scenes_list[idx + 1], scenes_list[idx]);\n        this._sceneDB.setScenesList(scenes_list);\n    }\n    _removeSceneTagFromAllCells(nbPanel, scene_name) {\n        const tag = this._getSceneTag(scene_name);\n        const notebook = nbPanel.content;\n        notebook.widgets.map((cell) => {\n            if (!!cell.model.getMetadata(tag)) {\n                cell.model.deleteMetadata(tag);\n            }\n        });\n    }\n    _renameSceneTagFromAllCells(nbPanel, old_scene_name, new_scene_name) {\n        const old_tag = this._getSceneTag(old_scene_name);\n        const new_tag = this._getSceneTag(new_scene_name);\n        const notebook = nbPanel.content;\n        notebook.widgets.map((cell) => {\n            if (!!cell.model.getMetadata(old_tag)) {\n                cell.model.deleteMetadata(old_tag);\n                cell.model.setMetadata(new_tag, true);\n            }\n        });\n    }\n    _duplicateSceneTagInAllCells(nbPanel, source_scene_name, target_scene_name) {\n        console.log('dup', nbPanel, source_scene_name, target_scene_name);\n        const source_tag = this._getSceneTag(source_scene_name);\n        const target_tag = this._getSceneTag(target_scene_name);\n        const notebook = nbPanel.content;\n        notebook.widgets.map((cell) => {\n            console.log('iter', source_tag, cell);\n            if (!!cell.model.getMetadata(source_tag)) {\n                console.log('inside', target_tag);\n                cell.model.setMetadata(target_tag, true);\n            }\n        });\n    }\n    _scenesChanged() {\n        const activeScene = this._sceneDB.getActiveScene();\n        if (!activeScene)\n            return;\n        let activeNotebookPanel = this._nbTracker.currentWidget;\n        this._nbTracker.forEach((nbPanel) => {\n            if (nbPanel.context === activeNotebookPanel.context) {\n                this.updateCellClassesAndTags(nbPanel.content, activeScene);\n            }\n        });\n        this._writeCellMetadataForLegacyInitializationCellsPlugin(activeNotebookPanel.content);\n        this.scenesChanged.emit(void 0);\n    }\n    _getSceneTag(scene_name) {\n        return 'scene__' + scene_name;\n    }\n}\nclass NotebookSceneDatabase {\n    constructor(nbTracker) {\n        this._nbTracker = nbTracker;\n    }\n    /* ****************************************************************************************************************************************\n     * Data access\n     * ****************************************************************************************************************************************/\n    // **** simple getters *************************************************\n    getNotebookTitle() {\n        if (!this._nbTracker.currentWidget) {\n            return null;\n        }\n        return PathExt.basename(this._nbTracker.currentWidget.context.localPath);\n    }\n    getScenesList() {\n        let data = this._getSceneDataAndMaybeSetupDefaultData();\n        if (!data)\n            return [];\n        return data['scenes'];\n    }\n    getActiveScene(notebook = null) {\n        let data = this._getSceneDataAndMaybeSetupDefaultData(notebook);\n        if (!data)\n            return null;\n        return data['active_scene'];\n    }\n    getInitScene() {\n        let data = this._getSceneDataAndMaybeSetupDefaultData();\n        if (!data)\n            return null;\n        return data['init_scene'];\n    }\n    // **** scene setters **************************************************\n    toggleInitScene(scene_name) {\n        let data = this._getSceneDataAndMaybeSetupDefaultData();\n        if (!data)\n            return;\n        if (data['init_scene'] == scene_name) {\n            data['init_scene'] = null;\n        }\n        else {\n            data['init_scene'] = scene_name;\n        }\n        this._setSceneData(data);\n    }\n    setActiveScene(scene_name) {\n        let data = this._getSceneDataAndMaybeSetupDefaultData();\n        if (!data)\n            return;\n        data['active_scene'] = scene_name;\n        this._setSceneData(data);\n    }\n    setScenesList(scene_list) {\n        let data = this._getSceneDataAndMaybeSetupDefaultData();\n        if (!data)\n            return;\n        data['scenes'] = scene_list;\n        this._setSceneData(data);\n    }\n    /* ****************************************************************************************************************************************\n     * Helpers\n     * ****************************************************************************************************************************************/\n    _getSceneDataAndMaybeSetupDefaultData(notebook = null) {\n        if (!notebook) {\n            notebook = this._nbTracker.currentWidget.content;\n        }\n        let model = notebook.model;\n        if (!model) {\n            return null;\n        }\n        if (model.getMetadata(NB_METADATA_KEY) == null) {\n            console.log('setting default scene data!!!!!!!!!!!');\n            model.setMetadata(NB_METADATA_KEY, { scenes: ['Default Scene'], active_scene: 'Default Scene', init_scene: '' });\n        }\n        let data_json = model.getMetadata(NB_METADATA_KEY);\n        let retval = {\n            scenes: data_json['scenes'],\n            active_scene: data_json['active_scene'],\n            init_scene: data_json['init_scene']\n        };\n        return retval;\n    }\n    _setSceneData(scene_data) {\n        var _a;\n        let notebook_model = (_a = this._nbTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.model;\n        if (!notebook_model)\n            return;\n        notebook_model.setMetadata(NB_METADATA_KEY, scene_data);\n    }\n}\n;\n","import * as React from 'react';\nimport { runIcon, closeIcon, editIcon, addIcon, copyIcon } from '@jupyterlab/ui-components';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { ScenesSidebar } from './widget';\nimport cellUp from '../style/svg/cellUp.svg';\nimport cellDown from '../style/svg/cellDown.svg';\nimport arrowUp from '../style/svg/arrowUp.svg';\nimport arrowDown from '../style/svg/arrowDown.svg';\nconst cellUpIcon = new LabIcon({ name: 'cellUp', svgstr: cellUp });\nconst cellDownIcon = new LabIcon({ name: 'cellDown', svgstr: cellDown });\nconst arrowUpIcon = new LabIcon({ name: 'arrowUp', svgstr: arrowUp });\nconst arrowDownIcon = new LabIcon({ name: 'arrowDown', svgstr: arrowDown });\nexport class ScenesDisplay extends React.Component {\n    render() {\n        return (React.createElement(\"div\", { className: \"scenes-ScenesSidebar\" },\n            React.createElement(\"div\", { className: \"scenes-Header\" },\n                this.props.nbTitle,\n                \": Scenes\"),\n            React.createElement(Toolbar, { commands: this.props.commands }),\n            React.createElement(ScenesList, { scenes: this.props.scenes, currentScene: this.props.currentScene, initScene: this.props.initScene, notebookHandler: this.props.notebookHandler, commands: this.props.commands })));\n    }\n}\nclass ScenesList extends React.Component {\n    render() {\n        let list = this.props.scenes.map(scene_name => {\n            const onClickActivate = () => {\n                this.props.notebookHandler.setActiveScene(scene_name);\n            };\n            const onClickDelete = (event) => {\n                event.preventDefault();\n                event.stopPropagation();\n                this.props.commands.execute(ScenesSidebar.command_id_delete_scene, { 'scene_name': scene_name });\n            };\n            const onClickEdit = (event) => {\n                event.preventDefault();\n                event.stopPropagation();\n                this.props.commands.execute(ScenesSidebar.command_id_rename_scene, { 'scene_name': scene_name });\n            };\n            const onClickInit = (event) => {\n                event.preventDefault();\n                event.stopPropagation();\n                this.props.notebookHandler.toggleInitScene(scene_name);\n            };\n            const onClickRun = (event) => {\n                event.preventDefault();\n                event.stopPropagation();\n                this.props.notebookHandler.runSceneInCurrentNotebook(scene_name);\n            };\n            let active = this.props.currentScene == scene_name;\n            let init = this.props.initScene == scene_name;\n            let className = active ? \"scenes-SceneItem scenes-active\" : \"scenes-SceneItem\";\n            let classNameInitButton = init ? \"scenes-InitSceneButtonActive\" : \"scenes-InitSceneButton\";\n            let sceneNameDisplay = active ? \"  \" + scene_name + \" (active)\" : \"  \" + scene_name;\n            return (React.createElement(\"div\", { className: className, onClick: onClickActivate, key: scene_name },\n                React.createElement(\"button\", { className: \"scenes-ItemButton\", title: \"Delete Scene\", onClick: onClickDelete },\n                    React.createElement(closeIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n                React.createElement(\"button\", { className: \"scenes-ItemButton\", title: \"Run Scene\", onClick: onClickRun },\n                    React.createElement(runIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n                React.createElement(\"button\", { className: \"scenes-ItemButton\", title: \"Rename Scene\", onClick: onClickEdit },\n                    React.createElement(editIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n                React.createElement(\"div\", { className: \"scenes-ItemText\" }, sceneNameDisplay),\n                React.createElement(\"div\", { className: \"scenes-SceneItemSpacer\" }),\n                React.createElement(\"button\", { onClick: onClickInit, className: classNameInitButton }, \"init\")));\n        });\n        return (React.createElement(\"div\", { className: \"scenes-SceneList\" }, list));\n    }\n}\nclass Toolbar extends React.Component {\n    render() {\n        const onClickNew = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_new_empty_scene);\n        };\n        const onClickDuplicate = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_duplicate_scene);\n        };\n        const onClickUp = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_move_active_scene_up);\n        };\n        const onClickDown = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_move_active_scene_down);\n        };\n        const onClickNext = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_to_next_scene_cell);\n        };\n        const onClickPrev = () => {\n            this.props.commands.execute(ScenesSidebar.command_id_to_previous_scene_cell);\n        };\n        return (React.createElement(\"div\", { className: \"scenes-Toolbar\" },\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"New Empty Scene\", onClick: onClickNew },\n                React.createElement(addIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"Duplicate Active Scene\", onClick: onClickDuplicate },\n                React.createElement(copyIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"Move Active Scene Up\", onClick: onClickUp },\n                React.createElement(arrowUpIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"Move Active Scene Down\", onClick: onClickDown },\n                React.createElement(arrowDownIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n            React.createElement(\"div\", { className: \"scenes-SceneItemSpacer\" }),\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"Jump to Next Scene Cell\", onClick: onClickNext },\n                React.createElement(cellDownIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" })),\n            React.createElement(\"button\", { className: \"scenes-ToolbarButton\", title: \"Move to Previous Scene Cell\", onClick: onClickPrev },\n                React.createElement(cellUpIcon.react, { tag: \"span\", className: \"jp-ToolbarButtonComponent-icon f1vya9e0\" }))));\n    }\n}\n","import { ILabShell } from '@jupyterlab/application';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ScenesSidebar } from './widget';\nfunction activateScenes(app, settingRegistry, nbTracker, mainMenu, labShell) {\n    // create the ScenesSidebar widget\n    const scenesSidebar = new ScenesSidebar(app, nbTracker, mainMenu, settingRegistry);\n    app.shell.add(scenesSidebar, 'left', { rank: 1000 });\n}\n/**\n * Initialization data for the jupyterlab_scenes extension.\n */\nconst plugin = {\n    id: 'jupyterlab_scenes:plugin',\n    autoStart: true,\n    optional: [ISettingRegistry, INotebookTracker, IMainMenu, ILabShell],\n    activate: activateScenes\n};\nexport default plugin;\n","import { Menu } from '@lumino/widgets';\nimport { ReactWidget, InputDialog, Dialog, showErrorMessage } from '@jupyterlab/apputils';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport React from 'react';\nimport { ScenesDisplay } from './components';\nimport { NotebookHandler } from './backend';\nimport scenesLogo from '../style/svg/scenesLogo.svg';\nconst scenesIcon = new LabIcon({ name: 'scenes', svgstr: scenesLogo });\nclass ScenesSidebar extends ReactWidget {\n    constructor(app, nbTracker, mainMenu, settingRegistry) {\n        super();\n        this._app = app;\n        this._nbTracker = nbTracker;\n        this._mainMenu = mainMenu;\n        this._scenesMenu = null;\n        this._notebookHandler = new NotebookHandler(nbTracker, settingRegistry);\n        this._setupWidget();\n        this._setupGlobalCommands();\n        this._setupKeyboardShortcuts();\n        this._setupScenesMenu();\n        // this is needed to sync ScenesSidebar and code cells on load\n        this._nbTracker.widgetAdded.connect((_x, nbpanel) => {\n            //console.log('widgetAdded', nbpanel.context.path)\n            nbpanel.context.ready.then(() => {\n                //console.log('context ready', nbpanel.context.path);\n                this._notebookHandler.updateCellClassesAndTags(nbpanel.content, this._notebookHandler.getActiveScene(nbpanel.content));\n                this._notebookHandler.importLegacyInitializationCells(nbpanel.content);\n                this.update();\n            });\n            // this is needed for handling copy/paste\n            nbpanel.content.activeCellChanged.connect((notebook, cell) => {\n                this._notebookHandler.updateCellClassesAndTags(notebook, this._notebookHandler.getActiveScene(), cell);\n            });\n        });\n        // this is needed syncing the ScenesSidebar to the current notebook panel\n        this._nbTracker.currentChanged.connect((sender, nbpanel) => {\n            //console.log('currentChanged', nbpanel!.context.path)\n            if (!(nbpanel === null || nbpanel === void 0 ? void 0 : nbpanel.context.isReady))\n                return;\n            this.update();\n        });\n        this._notebookHandler.scenesChanged.connect(() => { this.update(); });\n    }\n    render() {\n        let nb_title = this._notebookHandler.getNotebookTitle();\n        if (!nb_title)\n            return (React.createElement(\"div\", null));\n        return (React.createElement(ScenesDisplay, { nbTitle: nb_title, scenes: this._notebookHandler.getScenesList(), currentScene: this._notebookHandler.getActiveScene(), initScene: this._notebookHandler.getInitScene(), commands: this._app.commands, notebookHandler: this._notebookHandler }));\n    }\n    onNotebookChanged() {\n        this.update();\n    }\n    /* ****************************************************************************************************************************************\n     * Private helper methods\n     * ****************************************************************************************************************************************/\n    // **** setup helpers ****************************************************************************************************************\n    _setupWidget() {\n        this.id = 'scenes';\n        this.title.caption = 'Scenes';\n        this.title.icon = scenesIcon;\n    }\n    _setupGlobalCommands() {\n        this._app.commands.addCommand(ScenesSidebar.command_id_toggle_scene_cell, {\n            label: 'Toggle Scene Cell',\n            execute: () => { this._notebookHandler.toggleSceneMembershipOfSelectedCells(); }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_run_scene, {\n            label: 'Run Scene',\n            execute: () => { this._notebookHandler.runActiveSceneInCurrentNotebook(); }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_new_empty_scene, {\n            label: 'New Empty Scene',\n            execute: () => {\n                InputDialog.getText({ title: 'Name of the New Scene:' }).then((new_scene) => {\n                    if (!new_scene.value)\n                        return;\n                    if (this._notebookHandler.createNewEmptyScene(new_scene.value) == 'fail') {\n                        showErrorMessage('Error: New Scene Creation', 'Scene with name \"' + new_scene.value + '\" already exists!');\n                    }\n                });\n            }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_duplicate_scene, {\n            label: 'Duplicate Active Scene',\n            execute: () => {\n                InputDialog.getText({ title: 'Name of the Duplicated Scene:' }).then((new_scene) => {\n                    if (!new_scene.value)\n                        return;\n                    if (this._notebookHandler.duplicateActiveScene(new_scene.value) == 'fail') {\n                        showErrorMessage('Error: Scene Duplication', 'Scene with name \"' + new_scene.value + '\" already exists!');\n                    }\n                });\n            }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_delete_scene, {\n            label: 'Delete Scene',\n            execute: async (scene_name_obj) => {\n                let scene_name = scene_name_obj['scene_name'];\n                const result = await (new Dialog({\n                    title: 'Delete Scene \"' + scene_name + '\" permanently?',\n                    buttons: [Dialog.cancelButton(), Dialog.okButton({ label: 'Delete' })]\n                }).launch());\n                if (result.button.label == 'Delete') {\n                    this._notebookHandler.deleteScene(scene_name);\n                }\n            }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_rename_scene, {\n            label: 'Rename Scene',\n            execute: async (scene_name_obj) => {\n                let scene_name = scene_name_obj['scene_name'];\n                InputDialog.getText({ title: 'New Name of Scene \"' + scene_name + '\":' }).then((new_scene_name) => {\n                    if (!new_scene_name.value)\n                        return;\n                    if (this._notebookHandler.renameScene(scene_name, new_scene_name.value) == 'fail') {\n                        showErrorMessage('Error: Scene Renaming', 'Scene with name \"' + new_scene_name.value + '\" already exists!');\n                    }\n                });\n            }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_move_active_scene_up, {\n            label: 'Move Active Scene Up',\n            execute: () => { this._notebookHandler.moveActiveSceneUp(); }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_move_active_scene_down, {\n            label: 'Move Active Scene Down',\n            execute: () => { this._notebookHandler.moveActiveSceneDown(); }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_to_next_scene_cell, {\n            label: 'Jump to Next Scene Cell',\n            execute: () => { this._notebookHandler.jumpToNextSceneCell(); }\n        });\n        this._app.commands.addCommand(ScenesSidebar.command_id_to_previous_scene_cell, {\n            label: 'Jump to Previous Scene Cell',\n            execute: () => { this._notebookHandler.jumpToPreviousSceneCell(); }\n        });\n    }\n    _setupKeyboardShortcuts() {\n        this._app.commands.addKeyBinding({\n            command: ScenesSidebar.command_id_toggle_scene_cell,\n            args: {},\n            keys: ['Accel I'],\n            selector: '.jp-Notebook'\n        });\n        this._app.commands.addKeyBinding({\n            command: ScenesSidebar.command_id_run_scene,\n            args: {},\n            keys: ['Ctrl Alt R'],\n            selector: '.jp-Notebook'\n        });\n    }\n    _setupScenesMenu() {\n        this._scenesMenu = new Menu({ commands: this._app.commands });\n        this._scenesMenu.title.label = 'Scenes';\n        this._scenesMenu.addItem({ command: ScenesSidebar.command_id_toggle_scene_cell });\n        this._scenesMenu.addItem({ command: ScenesSidebar.command_id_run_scene });\n        this._scenesMenu.addItem({ type: 'separator' });\n        this._scenesMenu.addItem({ command: ScenesSidebar.command_id_new_empty_scene });\n        this._scenesMenu.addItem({ command: ScenesSidebar.command_id_duplicate_scene });\n        this._mainMenu.addMenu(this._scenesMenu);\n    }\n}\nScenesSidebar.command_id_toggle_scene_cell = 'scenes:toggle-scene-cell';\nScenesSidebar.command_id_run_scene = 'scenes:run-scene';\nScenesSidebar.command_id_new_empty_scene = 'scenes:new-empty-scene';\nScenesSidebar.command_id_duplicate_scene = 'scenes:duplicate-scene';\nScenesSidebar.command_id_rename_scene = 'scenes:rename-scene';\nScenesSidebar.command_id_delete_scene = 'scenes:delete-scene';\nScenesSidebar.command_id_move_active_scene_up = 'scenes:move-active-scene-up';\nScenesSidebar.command_id_move_active_scene_down = 'scenes:move-active-scene-down';\nScenesSidebar.command_id_to_next_scene_cell = 'scenes:jump-to-next-scene-cell';\nScenesSidebar.command_id_to_previous_scene_cell = 'scenes:jump-to-previous-scene-cell';\nexport { ScenesSidebar };\n;\n"],"names":[],"sourceRoot":""}