"""Point of entry for the test data generation framework."""

import argparse
import json
import random

from collections import defaultdict
from tqdm import tqdm
from typing import List, Optional

from de_utils.test_data_generation.columns import (
    DateColumn,
    DecimalColumn,
    StringColumn,
    TimestampColumn
)
from de_utils.test_data_generation.columns.base_columns import (
    BaseColumn,
    BaseNumericColumn
)


class TableGenerator:
    """Class for configuring and running test data generation for a table.

    `TableGenerator` can be configured imperitively via its public methods
    or directly from a `SchemaManager` schema file with
    `TableGenerator.from_schema()`.

    Attributes
    ----------
    null_proportion : int
        the desired proportion of null values (between 0 and 1)
    """

    _type_mappings = {
        "DateType": DateColumn,
        "DecimalType": DecimalColumn,
        "StringType": StringColumn,
        "TimestampType": TimestampColumn
    }

    def __init__(
        self, null_proportion: float = 0.0,
    ):
        """Initialise TableGenerator."""
        self._columns = []
        self._generation_args = defaultdict(dict)

        self.null_proportion = null_proportion

    @property
    def columns(self) -> List:
        """col_name getter."""
        return self._columns

    @columns.setter
    def columns(self, columns: List):
        # Type check that all columns are of type BaseColumn (base class)
        for column in columns:
            if not isinstance(column, BaseColumn):
                raise ValueError(f"Expected a Column, got {type(column)}.")

        self._columns = columns

    @property
    def null_proportion(self) -> float:
        """null_proportion getter."""
        return self._null_proportion

    @null_proportion.setter
    def null_proportion(self, null_proportion: float):
        if not (0 <= null_proportion <= 1):
            raise ValueError("null_proportion must be a float between 0 and 1 inclusive.")

        self._null_proportion = null_proportion

    @classmethod
    def from_schema(cls, schema_path: str, *args, **kwargs) -> 'TableGenerator':
        """Create a TableGenerator instance from a de-utils schema file.

        Examples
        --------
        >>> gen = TableGenerator.from_schema("schema.json")
        >>> gen.generate("data.csv")

        Parameters
        ----------
        schema_path : str
            path to a JSON schema file (generated by SchemaManager)
        args : list
            extra positional arguments
        kwargs: dict
            extra keyword arguments

        Returns
        -------
        TableGenerator
            a newly created generator instance
        """
        with open(schema_path) as f:
            schema = json.loads(f.read())

        columns = []

        for col_name, metadata in schema.items():
            dtype = metadata['dtype']
            base_args = {k: metadata[k] for k in ('distinct', 'nullable')}

            # Attempt to match type to a supported/implemented column
            try:
                type_match = next(
                    v for k, v in TableGenerator._type_mappings.items()
                    if dtype.startswith(k)
                )
            except StopIteration:
                # Catch invalid column types
                raise ValueError(
                    f"{col_name}'s dtype '{dtype} is invalid or not currently supported."
                )

            # StringType requires special parsing of length regex
            if dtype.startswith("StringType"):
                col = StringColumn.from_json(col_name, metadata, **base_args)
            # DecimalType requires special parsing of precision and scale
            elif dtype.startswith("DecimalType"):
                col = DecimalColumn.from_dtype_string(col_name, dtype, **base_args)
            # Base case for other columns where no special parsing is required
            elif type_match:
                col = type_match(col_name=col_name, **base_args)

            columns.append(col)

        gen = cls(*args, **kwargs)
        gen.columns = columns

        return gen

    def _get_generation_args(self, type):
        generation_args = {}
        base_classes = type.__mro__

        for base_class in base_classes[::-1]:
            generation_args.update(self._generation_args[base_class])

        return generation_args

    def disable_distinct(self) -> 'TableGenerator':
        """Disable the distinct flag on all columns."""
        for column in self.columns:
            column._disable_distinct()

        return self

    def enable_negatives(self) -> 'TableGenerator':
        """Enable the generation of negative values by DecimalColumn."""
        self._generation_args[BaseNumericColumn]['negatives_enabled'] = True

        return self

    def generate(
            self,
            output_path: str,
            desired_size: int = 100,
            batch_size: int = 10_000,
            output_headers: bool = True,
            delimiter: str = '|',
            quotechar: str = '"',
            encoding: str = "utf_8",
            show_progress: bool = True
    ):
        """Generate the desired number of rows and write to the destination file.

        # noqa: DAR103

        Parameters
        ----------
        output_path : str
            full or relative path to desired output location
        desired_size : int, default = 100
            the number of rows to generate
        batch_size : int
            the size of each batch (in rows) to be written
        output_headers : bool
            whether to write headers
        delimiter : str, default = '|'
            character separator between values in a row
        quotechar : str, default = '"'
            character used to denote quoted values, containing special characters
        encoding : str, default = 'utf_8'
            name of a supported codec, used to encode data when written
        show_progress : bool, default = True
            whether to show a progress bar as data is being generated
        """
        rows = []

        with open(output_path, "w", encoding=encoding, newline="") as f:
            # Write headers
            if output_headers:
                headers = [column.col_name for column in self.columns]
                f.write(delimiter.join(headers) + '\n')

            rows_iter = range(desired_size)
            if show_progress:
                rows_iter = tqdm(rows_iter, unit="row")
                rows_iter.set_description(output_path)

            for i in rows_iter:
                row = self._generate_row()
                rows.append(delimiter.join(row))

                # Write to CSV if batch_size reached or last row in table
                if not (i % batch_size) or i + 1 == desired_size:
                    for row in rows:
                        f.write(row + '\n')
                    rows = []

    def col(self, col_name: str) -> Optional[BaseColumn]:
        """Sequentially search for a column by its name.

        Parameters
        ----------
        col_name : str
            name of a column to be found

        Returns
        -------
        BaseColumn child class
            a column object with the name `col_name`
        """
        for column in self.columns:
            if column.col_name == col_name:
                return column

        return None

    def cols(self, *col_names) -> List[Optional[BaseColumn]]:
        """Sequentially search for multiple columns by name.

        Parameters
        ----------
        col_names : Iterable[str]
            names of multiple columns to find

        Returns
        -------
        List[BaseColumn child class or None]
            a list of column objects with the names `col_names`
        """
        return [self.col(col_name) for col_name in col_names]

    def _generate_row(self) -> List[str]:
        """Generate a row of generated values."""
        # Call each column's _generate() method
        return [
            column._generate(
                null_ind=self._get_null_ind(),
                **self._get_generation_args(type(column))
            )
            for column in self.columns
        ]

    def _get_null_ind(self) -> bool:
        """Generate a null indicator based on provided null_proportion."""
        if self.null_proportion > 0:
            return random.uniform(0, 1) < self.null_proportion
        else:
            return False

    @staticmethod
    def get_parser() -> argparse.ArgumentParser:
        """Build argument parser to taking CLI input for creating a TableGenerator.

        Returns
        -------
        ArgumentParser
            parser to interpret CLI input
        """
        parser = argparse.ArgumentParser("Generate test data")

        parser.add_argument(
            "-f",
            "--schema-path",
            required=True,
            type=str,
            help="Path to a de-utils/SchemaManager JSON schema file",
        )
        parser.add_argument(
            "-o",
            "--output-path",
            required=True,
            type=str,
            help="Path to the desired output location"
        )
        parser.add_argument(
            "-n",
            "--row-count",
            default=10,
            help="The desired number of records to be generated",
            type=int,
        )
        parser.add_argument(
            "-bs",
            "--batch-size",
            default=100000,
            type=int,
            help="The size of batches when writing to file"
        )
        parser.add_argument(
            "-dd",
            "--disable-distinct",
            action="store_true",
            help="Flag for whether to disable distinct compliance"
        )

        return parser


if __name__ == "__main__":
    parser = TableGenerator.get_parser()
    _args = parser.parse_args()

    gen = TableGenerator.from_schema(
        schema_path=_args.schema_path,
        output_path=_args.output_path,
        desired_size=_args.row_count,
        batch_size=_args.batch_size
    )

    if _args.disable_distinct:
        gen.disable_distinct()

    gen.generate()
