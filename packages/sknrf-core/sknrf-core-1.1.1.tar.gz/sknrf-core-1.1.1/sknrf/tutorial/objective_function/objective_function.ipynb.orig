{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sympy import sin, cos, Matrix\n",
    "from sympy.abc import x, y, z\n",
    "from sympy import diff\n",
    "\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Symbolic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "X = Matrix([x, y, z])\n",
    "F = Matrix([x*y + 2*z*x, 5*x + sin(y) + 3*z])\n",
    "f = F[0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def gradient(f, X):\n",
    "    \"\"\"Returns a tuple of length f.ndim where each entry represents a the numerical derivative Gj = df/dxj\"\"\"\n",
    "    return np.asarray([diff(f, x) for x in X])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def jacobian(F, X):\n",
    "    \"\"\"Returns array of shape len(f) x len(x) where each entry represents the first-order derivative Jij = dfi/dxj\"\"\"\n",
    "    return np.asarray([[diff(f, x) for x in X] for f in F])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def hessian(f, X):\n",
    "    \"\"\"Returns array of shape len(f) x len(x) where each entry represents the first-order derivative Jij = dfi/dxj\"\"\"\n",
    "    return jacobian(gradient(f, X), X).T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3,)\n",
      "[y + 2*z x 2*x]\n"
     ]
    }
   ],
   "source": [
    "G = gradient(f, X)\n",
    "print(G.shape)\n",
    "print(G)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2, 3)\n",
      "[[y + 2*z x 2*x]\n",
      " [5 cos(y) 3]]\n"
     ]
    }
   ],
   "source": [
    "J = jacobian(F, X)\n",
    "print(J.shape)\n",
    "print(J)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3)\n",
      "[[0 1/2 1]\n",
      " [1/2 0 0]\n",
      " [1 0 0]]\n"
     ]
    }
   ],
   "source": [
    "H = hessian(f, X)\n",
    "print(H.shape)\n",
    "print(H/np.max(H))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Numeric"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "x = np.linspace(-0.001, 0.00101, 3).reshape(-1, 1, 1)\n",
    "y = np.linspace(-0.001, 0.00101, 3).reshape(1, -1, 1)\n",
    "z = np.linspace(-0.001, 0.00101, 3).reshape(1, 1, -1)\n",
    "\n",
    "F = np.array([x*y + 2*z*x, 5*x + np.sin(y) + 3*z]) # Need be size 3*X and shape f_i, x_1, x_2,..., x_j\n",
    "X1 = np.asarray([x, y, z])\n",
    "X2 = np.asarray([np.squeeze(x) for x in X1])\n",
    "f = F[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def gradient(f, X):\n",
    "    \"\"\"Returns a tuple of length f.ndim where each entry represents a the numerical derivative Gj = df/dxj\"\"\"\n",
    "    return np.asarray([(np.diff(f, 1, j)/np.diff(x, 1, j)) for j, x in enumerate(X)])\n",
    "\n",
    "def gradient2(f, *X):\n",
    "    return np.asarray(np.gradient(f, *X))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def jacobian(F, X):\n",
    "    \"\"\"Returns array of shape len(f) x len(x) where each entry represents the first-order derivative Jij = dfi/dxj\"\"\"\n",
    "    return np.asarray([[np.diff(f, 1, j)/np.diff(x, 1, j) for j, x in enumerate(X)] for f in F])\n",
    "\n",
    "def jacobian2(F, *X):\n",
    "    return np.stack([np.gradient(f, *X) for f in F]) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def hessian(f, *X):\n",
    "    \"\"\"Returns array of shape len(f) x len(x) where each entry represents the first-order derivative Jij = dfi/dxj\"\"\"\n",
    "    return np.swapaxes(jacobian2(gradient2(f, *X), *X), 0, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3,)\n",
      "(2, 3, 3) (3, 2, 3) (3, 3, 2)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "-0.0029999999999999996"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "G = gradient(f, X1)\n",
    "print(G.shape)\n",
    "print(G[0].shape, G[1].shape, G[2].shape)\n",
    "G[0][0, 0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3, 3, 3)\n",
      "(3, 3, 3) (3, 3, 3) (3, 3, 3)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "-0.0029999999999999996"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "G = gradient2(f, *X2)\n",
    "print(G.shape)\n",
    "print(G[0].shape, G[1].shape, G[2].shape)\n",
    "G[0, 0, 0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2, 3)\n",
      "(2, 3, 3) (3, 2, 3) (3, 3, 2)\n",
      "(2, 3, 3) (3, 2, 3) (3, 3, 2)\n"
     ]
    }
   ],
   "source": [
    "J = jacobian(F, X1)\n",
    "print(J.shape)\n",
    "print(J[0, 0].shape, J[0, 1].shape, J[0, 2].shape)\n",
    "print(J[1, 0].shape, J[1, 1].shape, J[1, 2].shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2, 3, 3, 3, 3)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "-0.0029999999999999996"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "J = jacobian2(F, *X2)\n",
    "print(J.shape)\n",
    "J[0, 0, 0, 0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3, 3, 3, 3)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[  0.00000000e+00,   5.00000000e-01,   1.00000000e+00],\n",
       "       [  5.00000000e-01,   0.00000000e+00,   0.00000000e+00],\n",
       "       [  1.00000000e+00,  -1.07880813e-16,   0.00000000e+00]])"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "H = hessian(f, *X2)\n",
    "print(H.shape)\n",
    "H[:, :, 2, 2, 2]/np.max(H[:, :, 2, 2, 2])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Numeric with Sub-Sweep"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3, 3, 99) (3, 3, 99)\n"
     ]
    }
   ],
   "source": [
    "x = np.linspace(-0.001, 0.00101, 3).reshape(-1, 1, 1, 1, 1)\n",
    "y = np.linspace(-0.001, 0.00101, 3).reshape(1, -1, 1, 1, 1)\n",
    "z = np.linspace(-0.001, 0.00101, 3).reshape(1, 1, -1, 1, 1)\n",
    "s1 = np.linspace(-0.001, 2, 9).reshape(1, 1, 1, -1, 1)\n",
    "s2 = np.linspace(-0.001, 2, 11).reshape(1, 1, 1, 1, -1)\n",
    "num_vars = 3\n",
    "axes = np.arange(0, num_vars)\n",
    "\n",
    "shape_ = (x.size, y.size, z.size, s1.size*s2.size)\n",
    "F = np.array([x*y + 2*z*x + s1 + s2, 5*x + np.sin(y) + 3*z + s1 + s2]) # Need be size 3*X and shape f_i, x_1, x_2,..., x_j\n",
    "F = np.stack([f.reshape(shape_) for f in F], axis=0)\n",
    "f = F[0]\n",
    "fill = np.zeros((1, s1.size*s2.size))\n",
    "X = np.asarray([x.reshape(-1, 1) + fill, y.reshape(-1, 1) + fill, z.reshape(-1, 1) + fill])\n",
    "print(f.shape, X.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def gradient2(f, *X, axis=None):\n",
    "    gradient = np.zeros((len(X),) + f.shape, dtype=complex)\n",
    "    for sweep_index in range(f.shape[-1]):\n",
    "        X_vars = [x[:, sweep_index] for x in X]\n",
    "        f_vars = f[..., sweep_index]\n",
    "        gradient[..., sweep_index] = np.gradient(f_vars, *X_vars, axis=axis)\n",
    "    return gradient"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def jacobian2(F, *X, axis=None):\n",
    "    return np.stack([gradient(f, *X, axis=axis) for f in F])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def hessian(f, *X, axis=None):\n",
    "    return np.swapaxes(jacobian(gradient(f, *X, axis=axis), *X, axis=axis), 0, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "cannot copy sequence with size 3 to array axis with dimension 0",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-88-ef58902b0c5c>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mG\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mgradient2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mf\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mG\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mG\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mG\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mG\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0mG\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-85-236bb8ff8dfa>\u001b[0m in \u001b[0;36mgradient2\u001b[0;34m(f, axis, *X)\u001b[0m\n\u001b[1;32m      4\u001b[0m         \u001b[0mX_vars\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msweep_index\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mx\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mX\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m         \u001b[0mf_vars\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mf\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m...\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msweep_index\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m         \u001b[0mgradient\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m...\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msweep_index\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mgradient\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mf_vars\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX_vars\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[0mgradient\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: cannot copy sequence with size 3 to array axis with dimension 0"
     ]
    }
   ],
   "source": [
    "G = gradient2(f)\n",
    "print(G.shape)\n",
    "print(G[0].shape, G[1].shape, G[2].shape)\n",
    "G[0, 0, 0, 0, 0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "gradient() got an unexpected keyword argument 'axis'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-74-29f57c187bd3>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mJ\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mjacobian2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mF\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX2\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[0mnum_vars\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mtuple\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0maxes\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mJ\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0mJ\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-71-facc4890e596>\u001b[0m in \u001b[0;36mjacobian2\u001b[0;34m(F, axis, *X)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mjacobian2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mF\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m     \u001b[1;32mreturn\u001b[0m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstack\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mgradient\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mf\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mf\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mF\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-71-facc4890e596>\u001b[0m in \u001b[0;36m<listcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mjacobian2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mF\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m     \u001b[1;32mreturn\u001b[0m \u001b[0mnp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstack\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mgradient\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mf\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0mX\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0maxis\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mf\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mF\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m: gradient() got an unexpected keyword argument 'axis'"
     ]
    }
   ],
   "source": [
    "J = jacobian2(F, *X2[0:num_vars], axis=tuple(axes))\n",
    "print(J.shape)\n",
    "J[0, 0, 0, 0, 0, 0, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3, 3, 3, 3, 3, 9, 11)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[ -2.14682818e-13,   5.00000000e-01,   1.00000000e+00],\n",
       "       [  5.00000000e-01,   0.00000000e+00,   0.00000000e+00],\n",
       "       [  1.00000000e+00,   0.00000000e+00,  -1.07449290e-13]])"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "H = hessian(f, *X2[0:num_vars], axis=tuple(axes))\n",
    "print(H.shape)\n",
    "H[:, :, 2, 2, 2, 0, 0]/np.max(H[:, :, 2, 2, 2, 0, 0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Where/When to Calculate Gradient, Jacobian, Hessian\n",
    "\n",
    "### Multi-Objective and Multi-Variate\n",
    "1. The Hessian is scalar function (single objective/multi-variate)\n",
    "2. The Jaacobian is a vector function (multi-objective/multi-variate)\n",
    "3. The Numerical Jacobian uses a scalar Gradient => (single objective/multi-variate)\n",
    "\n",
    "Therefore it is best to only do single objective minimizations.\n",
    "\n",
    "### When Each be calcualted\n",
    "1. The Hessian requires 3*num_variables measurements (2nd Order).\n",
    "2. The Jacobian requires 2*num_variables measurements (1st Order).\n",
    "3. The Numerical Jacobian uses a scalare Gradient that uses cnetral difference equations => 3*num_variables\n",
    "\n",
    "So, if the minimization uses a Jacobian/Hessian it must record atleast 3 measurements.\n",
    "\n",
    "### How to get the first 3 measurements\n",
    "1. Repeat the first measurement and rely on measurement noise to vary parameters (Infinitesimally small derivatives).\n",
    "2. Perform and initial random sweep of 3 points for each variable (bounds??)\n",
    "\n",
    "Since a measurement always has noise, the first option is easier and provides a good initial Jacobian/Hessian. It could be implementd by simply refusing to evaluate the next guess until 3 measurements are completed.\n",
    "\n",
    "### Where should the Function/Jacobian/Hessian\n",
    "1. We know this will likely always be limited to a single objective function.\n",
    "2. Requires access to X (indep_map), F (objective function evaluation of dataset vars), over all realtime sweeps.\n",
    "3. The evaluation could take place:\n",
    "    a) In SweepIter.__next__\n",
    "      - self.indep_map, NO DATASET, minimize.goal, self.step = realtime sweep size\n",
    "    b) In Minimize.__next__\n",
    "      - Abstract.indep_map, datagroup_model.dataset, self.goal, Abstract.indep_map[\"realtime\"]\n",
    "    c) In Objective.__next__, Objective.__jac__, Objective.__hess__\n",
    "      - generator function for each realtime index. \n",
    "      - Could access Mnimize.__call__, __jac__, __hess__, which is a class funcs Goal.__call__, __jac__, __hess__\n",
    "      - Need to index in each instance goal\n",
    "\n",
    "### Actions\n",
    "1. Calculate Goal.Call/Jacobian/Hessian during AbstractMinimize.__next__ (Done)\n",
    "2. Remove index into Goal.call/jacobian/hessian (Done)\n",
    "3. Store realtime_index in Goal (Done)\n",
    "4. Replace Goal input parameters with Minimize.__call__, Minimize__jac__, Minimize.__hess__(Done)\n",
    "5. Don't stop optimizing if some goals reach completion.  (Not Done)\n",
    "6. Find some way to bypass __jac__/__hess__ if more measurements are needed (Do Something with goal.order)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.4.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
