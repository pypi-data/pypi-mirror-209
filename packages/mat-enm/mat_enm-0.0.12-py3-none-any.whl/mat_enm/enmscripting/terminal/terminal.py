#!/usr/bin/python -tt
from __future__ import absolute_import
import logging
from ..common.element import *
from ..common.output import Output
from ..common.output import OutputFactory
from ..exceptions import *
from ..private.executionhandler import ExecutionHandler
from six.moves import range

logger = logging.getLogger(__name__)


class EnmTerminal(object):
    """
    This class allows the execution of a command in the same way as the web-cli does. The return is a
    TerminalOutput instance which holds the text lines generated by the command execution. The content is the same as it
    would be in the web-cli.
    """

    _CONTENT_TYPE = 'application/vnd.com.ericsson.oss.scripting.terminal+json'
    _SERVER_VERSION = 'VERSION="3"'
    _MEDIA_TYPE = _CONTENT_TYPE + ';' + _SERVER_VERSION

    def __init__(self, session=None):
        self._handler = ExecutionHandler(session, TerminalOutputFactory(), self._MEDIA_TYPE)

    def execute(self, command_str, file=None, timeout_seconds=600):
        """
        Execute the command and return the result from enm.

        :param command_str:    command to be executed. For more information about a command's syntax, please
        check the web-cli online help
        :param file:       file object to be imported  - optional parameter - needed if the command requires a file for
        upload
        :param timeout_seconds: number of seconds before a timeout will occur on a command. Default value = 600 seconds
        :return TerminalOutput: TerminalOutput instance
        """
        logger.debug('Executing Terminal command...')
        return self._handler.execute(command_str, file, timeout_seconds)


class TerminalOutput(Output):
    """
     Class representing the output of the command execution
    """

    # SE specific KEYS in the response JSON
    _OUTPUT_KEY = 'output'
    _ATTACHMENTS_KEY = 'attachments'
    _APPLICATION_ID_KEY = 'applicationId'
    _FILE_ID = 'fileId'

    def __init__(self, http_code, success, json_response=None, handler=None):
        """
        :param http_code:       http_response code
        """
        self._result_lines = None
        self._files = None
        super(TerminalOutput, self).__init__(http_code, success, json_response, handler)

    def _process_complete_json(self, json):
        elements = self._create_elements(json[self._OUTPUT])
        self._files = elements._find_by_type(FileElement)

        self._result_lines = self._print_element(elements)

    @staticmethod
    def _print_element(element):
        def default_to_empty(value):
            return value if value is not None else ''

        list_output = []
        if isinstance(element, TextElement):
            list_output.append(element.value())
        elif isinstance(element, ElementGroup):
            if element.has_elements():
                if element.labels():
                    list_output.append(' '.join(element.labels()))

                if TerminalOutput._is_table_group(element):
                    # this is the start of a table
                    headers = [' '.join(col.labels()) for col in element[0]]
                    list_output.append('\t'.join(headers))

                    for row in element:
                        cells = [TerminalOutput._print_element(coll) for coll in row]
                        max_lines = max([len(cell) for cell in cells])
                        for line_num in range(max_lines):
                            line = ''
                            col_separator = ''
                            for cell in cells:
                                line += col_separator + default_to_empty(cell[line_num]) if line_num < len(cell) else ''
                                col_separator = '\t'
                            list_output.append(line)
                else:
                    for child_element in element:
                        list_output.extend(TerminalOutput._print_element(child_element))

        return list_output

    @staticmethod
    def _is_table_group(element):
        if isinstance(element, ElementGroup) and element._has_group_key():
            return True
        return False

    def get_output(self):
        """
        :return:                list of strings representing the output from the command
                                lines are single strings;
                                table rows are single strings with tabs delimiting columns
        """
        logger.debug('get_output')
        if not self._success:
            logger.warn('There is no output to parse, because command execution failed: raising IllegalStateException')
            raise IllegalStateException('There is no output to parse, because command execution failed')

        self._error_if_not_completed()

        if self._result_lines is not None:
            logger.debug('get_output returning lines')
            return self._result_lines[:]
        else:
            logger.warn('Illegal server response. Raising InternalError')
            raise InternalError('Illegal server response')

    def has_files(self):
        """
        :return:                boolean, true if there are files in the response
        """
        return True if self._files and len(self._files) > 0 else False

    def files(self):
        """
        :return:                List of FileResult items
        """
        if not self.has_files():
            return []

        return self._files[:]

    def __str__(self):
        return 'has-result: %s\nhas-file: %s\noutput:\n%s' % (self.is_command_result_available(),
                                                              self.has_files(),
                                                              '\n'.join(self.get_output()) if self._success else '')


class TerminalOutputFactory(OutputFactory):
    """
        Class instantiating an instance of TerminalOutput
    """

    def __init__(self):
        super(TerminalOutputFactory, self).__init__()

    def create_output(self, http_code, success, json_response=None, handler=None):
        return TerminalOutput(http_code, success, json_response, handler)
