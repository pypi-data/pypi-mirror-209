{# USES_VARIABLES {N} #}
{% extends 'common_group.py_' %}

{% block maincode %}

    # constants
    {% for c in constants %}
    {{ c }}
    {% endfor%}

    # Collect all the incoming variables from the synapses
    # We could have multiple inputs depending on the synaptic model:
    # e.g. if we have v += w + g*I and both w and g are synaptic variables, but I is a neuronal variable.
    # This allows for more generalizable models. 
    # TODO: handle the case in which no neuronal variable is on the right of the equation (i.e. just send the result of the operation).
    {% for var in read_port_input %}
    {{var}}
    {% endfor %}

    # We assume there is always one InPort in the NeuronGroup
    # To check which indices to use we check for our "nan equivalent": {{nan}}
    _activation_indices = np.where({{neur_input_vars[0]}}!= {{nan}})[0]

    # scalar code
    _vectorisation_idx = 1
    {{scalar_code|autoindent}}

    # vector code
    _idx = _activation_indices
    _vectorisation_idx = _idx
    {{vector_code|autoindent}}

{% endblock %}