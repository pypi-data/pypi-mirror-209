# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_connectors.ipynb.

# %% auto 0
__all__ = ['aws_client_config', 'client', 'ci_client', 'BASE_URL', 'VERSION', 'DEFAULT_CHAIN', 'PERIODS', 'URI',
           'IPFS_PUB_GATEWAY', 'authenticate', 'RSConnector', 'APIConnector', 'W3Connector', 'Connector']

# %% ../nbs/00_connectors.ipynb 3
import redshift_connector
import boto3
import json
import requests
import uuid
import pandas as pd
from functools import cache
from redshift_connector import Connection
from botocore.exceptions import ClientError
from botocore.config import Config
from fastcore.meta import delegates
from fastcore.basics import basic_repr
from functools import cache
from urllib.parse import urljoin
# needed for web3 client
from web3 import Web3
from web3.middleware import geth_poa_middleware
from box import Box

# %% ../nbs/00_connectors.ipynb 5
aws_client_config = Config(region_name="eu-west-1")
client = boto3.client("cognito-idp", config=aws_client_config)
ci_client = boto3.client("cognito-identity", config=aws_client_config)

def _fetch_dev_creds():
    """fetch api_key and db_user from parameter store"""
    ssm = boto3.client('ssm')
    return json.loads(ssm.get_parameter(
        Name='sdk-admin-creds',
    )['Parameter']['Value'])

@cache
def _authenticate(username, api_key):
    auth_res = client.initiate_auth(
        ClientId="377phvhgdn23vsor2ndafu02ek",
        AuthFlow="USER_PASSWORD_AUTH",
        AuthParameters={
            "USERNAME": username,
            "PASSWORD": api_key,
        },
    )["AuthenticationResult"]

    _logins = {
        "cognito-idp.eu-west-1.amazonaws.com/eu-west-1_NVKhGLh75":
        auth_res["IdToken"]
    }

    identity_id = ci_client.get_id(
        IdentityPoolId="eu-west-1:1b1ee2fe-2476-414c-9b29-993a56efb136",
        Logins=_logins,
    )["IdentityId"]

    return {
        **ci_client.get_credentials_for_identity(
            IdentityId=identity_id,
            Logins=_logins)["Credentials"],
        'username': username,
        'api_key': api_key
    }
def _connect_to_redshift(creds):
    return redshift_connector.connect(
        iam=True,
        database="prod",
        db_user=creds['username'],
        cluster_identifier="redshift-cluster-1",
        access_key_id=creds["AccessKeyId"],
        secret_access_key=creds["SecretKey"],
        session_token=creds["SessionToken"],
        region="eu-west-1",
    )
def _connect_to_redshift_dev():
    return _connect_to_redshift({
        'username': _fetch_dev_creds()['db_user'],
        "AccessKeyId": None,
        "SecretKey": None,
        "SessionToken": None
    })
def authenticate(
    username: str,  # username, usually your email
    api_key: str,  # generated api_key, you can request one from zash.sh
) -> redshift_connector.Connection:
    """Authenticate and get Zash data warehouse connection"""
    try:
        if username == "your_username" or api_key == "your_api_key":
            return _connect_to_redshift_dev()
        return _connect_to_redshift(_authenticate(username, api_key))
    except ClientError as e:
        if not len(e.args):
            raise e
        if "ExpiredToken" in e.args[0]:
            _authenticate.cache_clear()
            return _connect_to_redshift(_authenticate(username, api_key))

# %% ../nbs/00_connectors.ipynb 6
class RSConnector:
    """Redshift connector"""
    def __init__(self, username: str, api_key: str):
        self._conn = authenticate(username, api_key)
        self.username, self.api_key = username, api_key
    def refresh(self):
        self.close()
        self._conn = authenticate(self.username, self.api_key)
    def _fetch(self, statement: str):
        try:
            cur = self._conn.cursor()
            cur.execute(statement)
            df = cur.fetch_dataframe()
            cur.close()
            return df
        except Exception as e:
            # maybe add more details
            self._conn.rollback()
            cur.close()
            raise e
    def query(self, statement: str):
        try:
            return self._fetch(statement)
        except ClientError as e:
            if not len(e.args): raise e
            if "ExpiredToken" in e.args[0]:
                print('Session expired, reauthenticating...')
                self.refresh()
                return self._fetch(statement)
    def close(self):
        self._conn.close()

# %% ../nbs/00_connectors.ipynb 9
BASE_URL = "https://api.zash.sh"
VERSION = "v2"
DEFAULT_CHAIN = "eth"
PERIODS = {"1d", "1w", "1m", "all"}

class APIConnector:
    """Zash API connector. See [API docs](https://zashapi.readme.io) for more details."""
    def __init__(self, base_url: str = BASE_URL, api_key: str = "") -> None:
        self._session = requests.Session()
        api_key = _fetch_dev_creds()['api_key'] if api_key == 'your_api_key' else api_key
        self._session.headers.update({"X-API-Key": api_key})
        self.base_url = base_url
        self.product = "nft"
        self.base_path = urljoin(base_url, f"{VERSION}/{self.product}")
    @delegates(requests.Session.get)
    def get(self, 
            path: str, # API path that is after the product (i.e nft), i.e. /socials/bayc
            *args, **kwargs):
        if not path.startswith('/'): path = '/' + path
        return self._session.get(self.base_path + path, *args, **kwargs)
    def close(self): self._session.close()

# %% ../nbs/00_connectors.ipynb 12
URI = {
    'bnb': 'https://bsc-dataseed2.binance.org',
    'eth':'https://mainnet.infura.io/v3/c13b727bfe204e51931409863f75ce15',
    'matic':'https://polygon-mainnet.infura.io/v3/c13b727bfe204e51931409863f75ce15'
}
IPFS_PUB_GATEWAY = 'https://ipfs.io'
_nft_metadata_abi = [{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]
def _w3_client(uri, chain):
    if chain == "eth":
        return Web3(Web3.HTTPProvider(uri))
    elif chain == "bnb":
        _w3 = Web3(Web3.HTTPProvider(uri))
        _w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        return _w3
class W3Connector:
    """Web3 connector to connect to RPC endpoints"""
    def __init__(self,
                 chain:str ='eth', # chain (e.g. eth or bnb)
                 uri: str = ''): # uri if needs customization
        self.uri = uri or URI[chain]
        self.chain = chain
        self._client = _w3_client(self.uri, self.chain)
    
    def get_token_metadata(self, token_id: int, collection_address: str, abi=_nft_metadata_abi):
        if collection_address == collection_address.lower():
            collection_address = Web3.toChecksumAddress(collection_address)
        token_id = int(token_id)
        token_uri = self._client.eth.contract(collection_address, abi=_nft_metadata_abi).functions.tokenURI(token_id).call()
        if token_uri.strip().startswith('ipfs'):
            token_uri = token_uri.replace('ipfs://', f'{IPFS_PUB_GATEWAY}/ipfs/')
        return Box({
            'uri': token_uri,
            **requests.get(token_uri).json()
        })

# %% ../nbs/00_connectors.ipynb 15
class Connector:
    def __init__(self, username: str, api_key:str):
        self._rs_connector, self._api_connector = RSConnector(username, api_key), APIConnector(api_key=api_key)
    @delegates(RSConnector.query)
    def query(self, *args, **kwargs): return self._rs_connector.query(*args, **kwargs)
    @delegates(APIConnector.get)
    def get(self, *args, **kwargs): return self._api_connector.get(*args, **kwargs)
    def rpc(self, chain: str): return W3Connector(chain=chain)
    def close(self):
        self._rs_connector.close()
        self._api_connector.close()
