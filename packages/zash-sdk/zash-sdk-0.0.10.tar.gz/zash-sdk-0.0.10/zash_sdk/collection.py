# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_collection.ipynb.

# %% auto 0
__all__ = ['NFTCollection', 'Token']

# %% ../nbs/01_collection.ipynb 4
import pandas as pd
from dateparser import parse as parse_date
from functools import cache
from dataclasses import dataclass
from datetime import datetime, timedelta
from .connectors import Connector
from fastcore.utils import patch
from fastcore.basics import basic_repr
from box import Box
from operator import attrgetter
from typing import Callable
from jinja2 import Template
from typing import Union

# %% ../nbs/01_collection.ipynb 5
def _parse_start_end_dates(start_time: str, end_time: str = "now") -> tuple[datetime]:
    # ensure you have end_time:
    end_time = end_time or 'now'
    shortcuts = {
        # put more here, but should be convertible to dateparser lib conventions.
        "latest": 'now',
    }
    start_time = str(datetime.utcnow().date()) if start_time == 'today' else start_time
    if start_time in shortcuts: start_time = shortcuts[start_time]
    return parse_date(start_time, settings={'TIMEZONE': 'UTC'}), parse_date(end_time, settings={'TIMEZONE': 'UTC'})

# %% ../nbs/01_collection.ipynb 7
def _sqlize_list(l: list): return ','.join(list(map(lambda x: "'" + x + "'", l)))

# %% ../nbs/01_collection.ipynb 8
def _chain_prefix(chain: str):
    return "" if chain == "eth" else chain + "_"


def _build_template(template_str: str, **render_kwargs):
    return (
        Template(template_str, lstrip_blocks=True, trim_blocks=True, autoescape=True)
        .render(**render_kwargs)
        .replace("\n", "")
        .replace("   ", " ")
        .replace("&#39;", "'")
    )


def _build_sol_trade_statement(
    start_dt: datetime,
    end_dt: datetime,
    collection_address: Union[str, list] = "",
    mints_only=False,
    token_id: str = "",
    expand_collection=True,
):
    table = "sol_trades" if not mints_only else "sol_mints"
    collection_addresses = ""
    if type(collection_address) == list:
        collection_address, collection_addresses = "", _sqlize_list(collection_address)
    if "," in collection_address:
        # assume this is sqlized
        collection_address, collection_addresses = "", collection_address

    template = """
        SELECT *
        FROM onchain.{{table}}
        WHERE date >= '{{start_date}}' AND date <= '{{end_date}}'
        AND hour >= {{start_hour}} AND hour <= {{end_hour}}
        AND block_time >= {{ start_ts }} AND block_time <= {{ end_ts }}
        {%- if collection_address %}
        AND collection = '{{ collection_address }}'
        {% endif %}
        {%- if collection_addresses %}
        AND collection_address IN ({{ collection_addresses }})
        {% endif %}
        {%- if token_id %}
        AND mint = '{{ token_id }}'
        {% endif %}
    """
    return _build_template(
        template,
        table=table,
        start_ts=round(start_dt.timestamp()),
        end_ts=round(end_dt.timestamp()),
        start_date=start_dt.date(),
        end_date=end_dt.date(),
        start_hour=start_dt.hour,
        end_hour=end_dt.hour,
        collection_addresses=collection_addresses,
        collection_address=collection_address,
        token_id=token_id,
    )


def _build_trade_statement(
    chain: str,
    start_dt: datetime,
    end_dt: datetime,
    collection_address: Union[str, list] = "",
    mints_only=False,
    token_id: str = "",
    expand_collection=False,
):
    if chain == "sol":
        return _build_sol_trade_statement(
            start_dt=start_dt,
            end_dt=end_dt,
            collection_address=collection_address,
            mints_only=mints_only,
            token_id=token_id,
            expand_collection=expand_collection,
        )
    table = f'{_chain_prefix(chain)}{"trades" if not mints_only else "mints"}'
    collection_addresses = ""
    if type(collection_address) == list:
        collection_address, collection_addresses = "", _sqlize_list(collection_address)
    if "," in collection_address:
        # assume this is sqlized
        collection_address, collection_addresses = "", collection_address

    template = """
        SELECT *
        FROM onchain.{{table}}
        WHERE timestamp >= {{ start_ts }} AND timestamp <= {{ end_ts }}
        {%- if collection_address %}
        AND collection_address = '{{ collection_address }}'
        {% endif %}
        {%- if collection_addresses %}
        AND collection_address IN ({{ collection_addresses }})
        {% endif %}
        {%- if token_id %}
        AND token_id = '{{ token_id }}'
        {% endif %}
    """
    t = _build_template(
        template,
        table=table,
        start_ts=round(start_dt.timestamp()),
        end_ts=round(end_dt.timestamp()),
        mints_only=mints_only,
        collection_addresses=collection_addresses,
        collection_address=collection_address,
        token_id=token_id,
    )
    if expand_collection:
        expanded_temp = """
            WITH x as ({{temp}})
            SELECT x.*, y.name, y.slug
            FROM x LEFT JOIN offchain.{{metadata_table}} y
            ON x.collection_address = y.collection_id
        """
        metadata_table = f"{_chain_prefix(chain)}collection_metadata"
        return (
            Template(expanded_temp, lstrip_blocks=True, trim_blocks=True)
            .render(temp=t, metadata_table=metadata_table)
            .replace("\n", "")
            .replace("   ", " ")
        )
    else:
        return t


def _build_loans_statement(
    chain: str,
    start_dt: datetime,
    end_dt: datetime,
):
    chain_prefix = _chain_prefix(chain)
    table = chain_prefix + "nft_loans"
    template = """
        SELECT *
        FROM onchain.{{table}}
        WHERE timestamp >= {{ start_ts }} AND timestamp <= {{ end_ts }}
    """
    return _build_template(
        template,
        table=table,
        start_ts=round(start_dt.timestamp()),
        end_ts=round(end_dt.timestamp()),
    )

# %% ../nbs/01_collection.ipynb 10
@cache
def __fetch_trades(
    conn: Connector,
    start_dt: datetime,  # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
    end_dt: datetime,  # default now. Same type as start_time
    chain: str = "eth",
    collection_address: str = "",  # collection address
    token_id: str = "",  # token id
    mints_only: bool = False,  # mints
    expand_collection: bool = False,
) -> pd.DataFrame:
    return conn.query(
        _build_trade_statement(
            chain,
            start_dt,
            end_dt,
            collection_address=collection_address,
            token_id=token_id,
            mints_only=mints_only,
            expand_collection=expand_collection,
        )
    )


def _fetch_trades(
    conn: Connector,
    start_time: str,  # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
    end_time: str = "now",  # default now. Same type as start_time
    chain: str = "eth",
    collection_address: Union[str, list] = "",  # collection address
    token_id: str = "",  # token id
    mints_only: bool = False,  # filter for mints if True
    expand_collection: bool = False,  # expand collection columns
) -> pd.DataFrame:
    start_dt, end_dt = _parse_start_end_dates(start_time, end_time=end_time)
    # we cache the one below because "yesterday" etc. style start_time is relative.
    # this is needed for caching:
    if type(collection_address) == list:
        if len(collection_address) > 0:
            collection_address = (
                _sqlize_list(collection_address)
                if len(collection_address) > 1
                else collection_address[0]
            )
        else:
            collection_address = ""

    return __fetch_trades(
        conn,
        start_dt,
        end_dt,
        chain=chain,
        collection_address=(
            collection_address.lower() if chain != "sol" else collection_address
        ),
        mints_only=mints_only,
        token_id=token_id,
        expand_collection=expand_collection,
    )


@cache
def __fetch_loans(
    conn: Connector,
    start_dt: datetime,  # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
    end_dt: datetime,  # default now. Same type as start_time
    chain: str = "eth",
) -> pd.DataFrame:
    return conn.query(_build_loans_statement(chain, start_dt, end_dt))


def _fetch_loans(
    conn: Connector,
    start_time: str,  # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
    end_time: str = "now",  # default now. Same type as start_time
    chain: str = "eth",
    collection_address: Union[str, list] = "",  # collection address
    token_id: str = "",  # token id
    mints_only: bool = False,  # filter for mints if True
    expand_collection: bool = False,  # expand collection columns
) -> pd.DataFrame:
    start_dt, end_dt = _parse_start_end_dates(start_time, end_time=end_time)
    if chain != "eth":
        raise Exception(f"Chain {chain} is not supported for this dataset")
    return __fetch_loans(conn, start_dt, end_dt, chain=chain)


@cache
def _fetch_metadata(conn: Connector, collection_id: str, chain: str = "eth"):
    res = conn.query(
        f"""
        select * from offchain.{_chain_prefix(chain)}collection_metadata
        where collection_id='{collection_id.lower()}'"""
    ).squeeze()
    res.name = res["name"]
    for i in [
        "volume_all",
        "volume_daily",
        "volume_weekly",
        "item_count",
        "floor_price",
    ]:
        if i in res:
            del res[i]
    return res


@cache
def _fetch_metadatas(conn: Connector, collection_ids: list[str], chain: str = "eth"):
    cs = ",".join(list(map(lambda i: "'" + i.lower() + "'", collection_id)))
    df = conn.query(
        f"""
        select * from offchain.{_chain_prefix(chain)}collection_metadata
        where collection_id IN ({cs})"""
    )
    df.drop(
        ["volume_all", "volume_daily", "volume_weekly", "item_count", "floor_price"],
        errors="ignore",
    )
    res.name = res["name"]
    for i in [
        "volume_all",
        "volume_daily",
        "volume_weekly",
        "item_count",
        "floor_price",
    ]:
        if i in res:
            del res[i]
    return res


@cache
def _fetch_socials(conn: Connector, collection_slug: str):
    return conn.get(f"/socials/{collection_slug}").json()

# %% ../nbs/01_collection.ipynb 11
class NFTCollection:
    """NFT Collection object"""
    def __init__(self,
                 conn: Connector,
                 collection_id: str, # collection_address e.g. 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
                 chain: str ='eth'): # chain_id - currently only "eth" or "bnb" allowed
        self._conn, self.chain, self.collection_id = conn, chain, (collection_id.lower() if chain != 'sol' else collection_id)

# %% ../nbs/01_collection.ipynb 12
@patch
def trades(self: NFTCollection,
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now', # default now. Same type as start_time 
           expand_collection: bool = False, # expand collection details (name, slug etc.)
          ):        
    return _fetch_trades(
        self._conn,
        start_time, 
        end_time=end_time, 
        chain=self.chain,
        collection_address=self.collection_id,
        expand_collection=expand_collection
    )

@patch
def token(self: NFTCollection, token_id: str):
    """Token model"""
    return Token(self._conn, token_id, self.collection_id, chain=self.chain)
@patch
def metadata(self: NFTCollection):
    """Returns metadata on a collection"""
    return _fetch_metadata(self._conn, self.collection_id, chain=self.chain)
@patch
def mints(self: NFTCollection,
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now', # default now. Same type as start_time 
           expand_collection: bool = False # expand collection details (name, slug etc.)
          ):
    return _fetch_trades(
        self._conn,
        start_time,
        end_time=end_time,
        chain=self.chain,
        collection_address=self.collection_id,
        mints_only=True,
        expand_collection=expand_collection
    )

# %% ../nbs/01_collection.ipynb 13
def _timeseries_to_df(timeseries: list) -> pd.DataFrame:
    """turn socials timeseries to pd dataframe"""
    if not timeseries: return timeseries
    _ts = pd.DataFrame([dict(i) for i in timeseries])
    _ts['ts'] = _ts['ts'].apply(pd.to_datetime)
    _ts.set_index('ts')
    return _ts

@patch
def socials(self: NFTCollection, collection_slug: str):
    _socials = Box(
        self._conn.get(f'/socials',
                       params={'id':collection_slug, 'chain': self.chain}).json()['social'])
    _socials.discord = _timeseries_to_df(_socials.discord.timeseries)
    _socials.twitter = _timeseries_to_df(_socials.twitter.timeseries)
    return _socials

# %% ../nbs/01_collection.ipynb 14
class Token:
    """Token model"""
    __repr__= basic_repr(['collection_id', 'token_id', 'token_type', 'chain'])
    def __init__(self, conn: Connector, token_id: str, collection_id:str, chain:str='eth', token_type='721'):
        self._conn, self.token_id, self.chain, self.token_type = conn, token_id, chain, token_type
        self.collection_id = collection_id
    def trades(self: 'Token',
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now' # default now. Same type as start_time 
          ):
        return _fetch_trades(
            self._conn,
            start_time,
            end_time=end_time, 
            chain=self.chain,
            collection_address=self.collection_id,
            token_id=self.token_id
        )
    @cache
    def metadata(self):
        """Token metadata fetched as is from offchain stores"""
        return self._conn.rpc(self.chain).get_token_metadata(self.token_id, self.collection_id)
