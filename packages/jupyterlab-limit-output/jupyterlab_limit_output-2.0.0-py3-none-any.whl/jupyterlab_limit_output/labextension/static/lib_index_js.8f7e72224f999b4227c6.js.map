{"version":3,"file":"lib_index_js.8f7e72224f999b4227c6.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA,sBAAsB,oBAAoB,OAAO,KAAK;AACtD;AACA,kBAAkB,QAAQ,EAAE,mBAAmB,kCAAkC,KAAK,aAAa,mBAAmB,EAAE,QAAQ;AAChI;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,kBAAkB,oBAAoB,OAAO,KAAK;AAClD;AACA,cAAc,QAAQ,EAAE,mBAAmB,kCAAkC,KAAK,QAAQ,mBAAmB,EAAE,QAAQ;AACvH;AACA,oBAAoB;;;;;;;;;;;AC/EP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,0BAA0B,mBAAO,CAAC,gGAA6B;AAC/D,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA,SAAS;AACT,0EAA0E,YAAY,IAAI,IAAI;AAC9F,SAAS;AACT,KAAK;AACL;AACA,kBAAe;;;;;;;;;;;ACtCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,sBAAsB,GAAG,iCAAiC;AACpF,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,mBAAmB,mBAAO,CAAC,kFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,4DAA4D,cAAc,sEAAsE;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa,EAAE,qBAAqB;AAClE;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA,8BAA8B,aAAa,EAAE,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAA2B;AACvE;AACA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E;AACA;AACA;AACA;AACA,kDAAkD,wCAAwC;AAC1F;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,cAAc,0BAA0B;AACtH;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab-limit-output/./lib/formatters.js","webpack://jupyterlab-limit-output/./lib/index.js","webpack://jupyterlab-limit-output/./lib/renders.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.limitByLines = exports.limitByCharacters = void 0;\nconst NEW_LINE = '\\n';\nconst SPACER = '\\n\\n\\n';\n/**\n * Return a string with at most head starting characters and tail ending (plus a warning)\n */\nconst limitByCharacters = (text, head, tail) => {\n    const maxChars = head + tail;\n    if (text.length > maxChars) {\n        const headstr = text.substring(0, head);\n        const tailstr = text.substring(text.length - tail);\n        let msg = '';\n        if (head) {\n            msg = ` first ${head}`;\n        }\n        if (tail) {\n            msg += `${head ? ' and' : ''} last ${tail}`;\n        }\n        return `${headstr}${head ? SPACER : ''}WARNING: Output limited. Showing${msg} characters.${tail ? SPACER : ''}${tailstr}`;\n    }\n    return text;\n};\nexports.limitByCharacters = limitByCharacters;\n/**\n * Find the nth index of the newline character\n */\nfunction _nthNewLineIndex(text, n) {\n    let idx = 0;\n    while (n-- > 0 && idx++ < text.length) {\n        idx = text.indexOf(NEW_LINE, idx);\n        // Not found before we ran out of n\n        if (idx < 0) {\n            return null;\n        }\n    }\n    return idx;\n}\n/**\n * Find the nth newline from the end of the string (excluding a possible final new line)\n */\nfunction _nthNewLineFromLastIndex(text, n) {\n    let idx = text.length - 1; // Ignore a possible final trailing \\n\n    while (n-- > 0 && idx-- >= 0) {\n        idx = text.lastIndexOf(NEW_LINE, idx);\n        // Not found before we ran out of n\n        if (idx < 0) {\n            return null;\n        }\n    }\n    return idx;\n}\n/**\n * Return a string with at most head starting lines and tail ending (plus a warning)\n */\nconst limitByLines = (text, head, tail) => {\n    const headEndPos = head > 0 ? _nthNewLineIndex(text, head) : -1;\n    if (headEndPos === null) {\n        return text;\n    }\n    const tailStartPos = tail > 0 ? _nthNewLineFromLastIndex(text, tail) : text.length;\n    if (tailStartPos === null) {\n        return text;\n    }\n    if (tailStartPos <= headEndPos) {\n        return text;\n    }\n    const headstr = text.substring(0, headEndPos);\n    const tailstr = text.substring(tailStartPos);\n    let msg = '';\n    if (head) {\n        msg = ` first ${head}`;\n    }\n    if (tail) {\n        msg += `${head ? ' and' : ''} last ${tail}`;\n    }\n    return `${headstr}${head ? SPACER : ''}WARNING: Output limited. Showing${msg} lines.${tail ? SPACER : ''}${tailstr}`;\n};\nexports.limitByLines = limitByLines;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rendermime_1 = require(\"@jupyterlab/rendermime\");\nconst settingregistry_1 = require(\"@jupyterlab/settingregistry\");\nconst renders_1 = require(\"./renders\");\nconst PLUGIN_NAME = 'jupyterlab-limit-output';\nconst extension = {\n    id: `${PLUGIN_NAME}:rendertext`,\n    rendererFactory: renders_1.rendererFactory,\n    // This number is NOT random. It's just lower (more preferred) than https://github.com/jupyterlab/jupyterlab/blob/0cbfcbe8c09d2c1fbfd1912f4d36c12479893946/packages/rendermime/src/factories.ts#L68\n    // Setting the rank too low makes the text version of renders too preferred (e.g. show text instead of the widget render)\n    rank: 119,\n    dataType: 'string',\n};\nconst RenderExtension = {\n    id: `${PLUGIN_NAME}:renders`,\n    autoStart: true,\n    requires: [rendermime_1.IRenderMimeRegistry, settingregistry_1.ISettingRegistry],\n    activate: function (app, rendermime, settingRegistry) {\n        // eslint-disable-next-line no-console\n        console.log('JupyterLab extension jupyterlab-limit-output is activated!');\n        rendermime.addFactory(extension.rendererFactory, extension.rank);\n        function updateSettings(settings) {\n            const head = settings.get('head').composite;\n            const tail = settings.get('tail').composite;\n            const enabled = settings.get('enabled').composite;\n            const method = settings.get('method')\n                .composite;\n            renders_1.updateLimitOutputSettings({ head, tail, method, enabled });\n        }\n        settingRegistry.load(`${PLUGIN_NAME}:settings`).then((settings) => {\n            updateSettings(settings);\n            settings.changed.connect(updateSettings);\n        }, (err) => {\n            console.error(`Could not load settings, so did not activate ${PLUGIN_NAME}: ${err}`);\n        });\n    },\n};\nexports.default = RenderExtension;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rendererFactory = exports.MyRenderedText = exports.updateLimitOutputSettings = void 0;\nconst rendermime_1 = require(\"@jupyterlab/rendermime\");\nconst formatters_1 = require(\"./formatters\");\nconst apputils_1 = require(\"@jupyterlab/apputils\");\nconst WARN_BEFORE_EXPANDING_SOURCE_LENGTH_CH = 100000;\nconst WARN_BEFORE_EXPANDING_SOURCE_LENGTH_LINES = 1000;\nlet limitSettings = {\n    head: 50,\n    tail: 50,\n    method: 'lines',\n    enabled: true,\n};\nconst updateLimitOutputSettings = (settings) => {\n    limitSettings = settings;\n    if (limitSettings.head < 0) {\n        limitSettings.head = 0;\n    }\n    if (limitSettings.tail < 0) {\n        limitSettings.tail = 0;\n    }\n    if (limitSettings.tail === 0 && limitSettings.head === 0) {\n        limitSettings.enabled = false;\n    }\n    if (limitSettings.method !== 'lines' &&\n        limitSettings.method !== 'characters') {\n        limitSettings.method = 'lines';\n    }\n};\nexports.updateLimitOutputSettings = updateLimitOutputSettings;\nconst limitOutputRenderText = async (options, _head = 0, _tail = 0, _cleanupButtonFn = null) => {\n    if (limitSettings.enabled) {\n        // We have to clone so that we can both keep track of number of head/tail\n        // shown as well as keep the original options unchanged\n        const clonedOptions = Object.assign(Object.assign({}, options), { head: _head || limitSettings.head, tail: _tail || limitSettings.tail });\n        if (limitSettings.method === 'characters') {\n            clonedOptions.source = formatters_1.limitByCharacters(options.source, clonedOptions.head, clonedOptions.tail);\n        }\n        else {\n            clonedOptions.source = formatters_1.limitByLines(options.source, clonedOptions.head, clonedOptions.tail);\n        }\n        // Add a div so we can easily remove output\n        const div = document.createElement('div');\n        options.host.append(div);\n        clonedOptions.host = div;\n        // Wait for text to render so that we can add our buttons after it\n        const ret = await rendermime_1.renderText(clonedOptions);\n        // If we need to, add buttons for expanding output\n        if (_cleanupButtonFn === null &&\n            clonedOptions.source.length !== options.source.length) {\n            const expandLines = Math.max(limitSettings.tail, limitSettings.head);\n            const span = document.createElement('span');\n            [\n                // label, expand head, expand tail, warn on click\n                [\n                    `↑ Show ${expandLines} ${limitSettings.method}`,\n                    expandLines,\n                    0,\n                    false,\n                ],\n                [`Show all ${limitSettings.method}`, Infinity, Infinity, true],\n                [\n                    `↓ Show ${expandLines} ${limitSettings.method}`,\n                    0,\n                    expandLines,\n                    false,\n                ],\n            ].map((b) => {\n                const [label, expandUp, expandDown, warnOnClick] = b;\n                const button = document.createElement('button');\n                button.innerText = label;\n                button.className = 'bp3-button jp-Button limit-output-button';\n                const cleanup = () => span.remove();\n                button.onclick = async () => {\n                    if (warnOnClick) {\n                        let warningLabel;\n                        if (limitSettings.method === 'lines') {\n                            let count = 0;\n                            for (let i = 0; i < options.source.length; ++i) {\n                                if (options.source[i] === '\\n') {\n                                    count++;\n                                }\n                            }\n                            if (count > WARN_BEFORE_EXPANDING_SOURCE_LENGTH_LINES) {\n                                warningLabel = `${count.toLocaleString()} lines`;\n                            }\n                        }\n                        else {\n                            if (options.source.length > WARN_BEFORE_EXPANDING_SOURCE_LENGTH_CH) {\n                                warningLabel = `${options.source.length.toLocaleString()} characters`;\n                            }\n                        }\n                        if (warningLabel) {\n                            const result = await apputils_1.showDialog({\n                                title: 'Show all',\n                                body: `Do you really want to show all ${warningLabel}?`,\n                            });\n                            if (!result.button.accept) {\n                                return;\n                            }\n                        }\n                    }\n                    // This binds the first clonedOptions call\n                    // i.e. future calls will updated clonedOptions but this onclick won't change\n                    clonedOptions.head += expandUp;\n                    clonedOptions.tail += expandDown;\n                    await limitOutputRenderText(Object.assign(Object.assign({}, options), { host: clonedOptions.host }), clonedOptions.head, clonedOptions.tail, cleanup);\n                    // Not the best design, but we know the prev element added is the renderText one\n                    // so we remove it before we redisplay\n                    clonedOptions.host.childNodes.forEach((n) => n.remove());\n                };\n                span.appendChild(button);\n            });\n            options.host.append(span);\n            // We are fully expanded!\n        }\n        else if (clonedOptions.source.length === options.source.length &&\n            _cleanupButtonFn) {\n            _cleanupButtonFn();\n        }\n        return ret;\n    }\n    return rendermime_1.renderText(options);\n};\nclass MyRenderedText extends rendermime_1.RenderedText {\n    /**\n     * Render a mime model.\n     *\n     * @param model - The mime model to render.\n     *\n     * @returns A promise which resolves when rendering is complete.\n     */\n    render(model) {\n        return limitOutputRenderText({\n            host: this.node,\n            sanitizer: this.sanitizer,\n            source: String(model.data[this.mimeType]),\n            translator: this.translator,\n        });\n    }\n    /**\n     * Dispose the contents of node to contain potential memory leak.\n     *\n     * **Notes**: when user attempts to clean the output using context menu\n     * they invoke `JupyterFrontEnd.evtContextMenu` which caches the event\n     * to enable commands and extensions to access it later; this leads to\n     * a memory leak as the event holds the target node reference.\n     */\n    dispose() {\n        // TODO: remove ts-ignore during JupyterLab 4.0/TypeScript 5.0 migration\n        // @ts-ignore\n        this.node.replaceChildren();\n        super.dispose();\n    }\n}\nexports.MyRenderedText = MyRenderedText;\nexports.rendererFactory = {\n    safe: true,\n    mimeTypes: [\n        'text/plain',\n        'application/vnd.jupyter.stdout',\n        'application/vnd.jupyter.stderr',\n    ],\n    createRenderer: (options) => new MyRenderedText(options),\n};\n"],"names":[],"sourceRoot":""}