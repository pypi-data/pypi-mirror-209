# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .create_payment_intent_pse_amount import CreatePaymentIntentPseAmount
from .enum_payment_link_allowed_payment_method import EnumPaymentLinkAllowedPaymentMethod
from .enum_payment_link_provider import EnumPaymentLinkProvider
from .payment_intents_payment_method_details_pse import PaymentIntentsPaymentMethodDetailsPse


class CreatePaymentIntentPse(pydantic.BaseModel):
    amount: CreatePaymentIntentPseAmount = pydantic.Field(
        description=(
            "Amount to be paid by your customer. For PSE, you can only send whole numbers. For example: `350000`.\n"
            "\n"
            "**Note:** You can send through this value either as a string or an integer. Regardless of the type you choose to send the `amount` as, Belvo returns a string with two decimal points, separated by a period ( `.`). For example, `350000.00`.\n"
        )
    )
    customer: str = pydantic.Field(description=("Belvo's unique ID to reference the customer.\n"))
    description: str = pydantic.Field(description=("The description of the payment.\n"))
    allowed_payment_method_types: typing.List[EnumPaymentLinkAllowedPaymentMethod] = pydantic.Field(
        description=(
            "A list of payment method types allowed in this payment intent. For PSE, this value must be set to `pse`.\n"
        )
    )
    payment_method_details: PaymentIntentsPaymentMethodDetailsPse
    provider: EnumPaymentLinkProvider
    metadata: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(
        description=(
            "Optional and customizable object where you can provide any additional key-value pairs for your internal purposes. For example, an internal reference number for the payment intent.\n"
            "\n"
            "⚠️ **Note**: You can only provide up to 50 keys (keys can have up to 50 characters each and each value can be up to 500 characters). We do not support nested objects, only ASCII values.\n"
        )
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        json_encoders = {dt.datetime: serialize_datetime}
