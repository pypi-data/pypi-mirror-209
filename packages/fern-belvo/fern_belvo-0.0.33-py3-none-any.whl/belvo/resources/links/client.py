# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...environment import BelvoEnvironment
from ...errors.bad_request_error import BadRequestError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.precondition_error import PreconditionError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.bad_request_error_body_item import BadRequestErrorBodyItem
from ...types.enum_link_access_mode_request import EnumLinkAccessModeRequest
from ...types.link import Link
from ...types.not_found_error_body import NotFoundErrorBody
from ...types.paginated_response_link import PaginatedResponseLink
from ...types.patch_body_without_save_data import PatchBodyWithoutSaveData
from ...types.token_required_response import TokenRequiredResponse
from ...types.unauthorized_error_body import UnauthorizedErrorBody
from ...types.unexpected_error import UnexpectedError

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class LinksClient:
    def __init__(
        self, *, environment: BelvoEnvironment = BelvoEnvironment.PRODUCTION, secret_id: str, secret_password: str
    ):
        self._environment = environment
        self._secret_id = secret_id
        self._secret_password = secret_password

    def list_links(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        access_mode: typing.Optional[str] = None,
        created_at: typing.Optional[str] = None,
        created_at_gt: typing.Optional[str] = None,
        created_at_gte: typing.Optional[str] = None,
        created_at_lt: typing.Optional[str] = None,
        created_at_lte: typing.Optional[str] = None,
        created_at_range: typing.Optional[str] = None,
        created_by_not_in: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        external_id_in: typing.Optional[str] = None,
        id: typing.Optional[str] = None,
        id_in: typing.Optional[str] = None,
        institution: typing.Optional[str] = None,
        institution_in: typing.Optional[str] = None,
        institution_user_id: typing.Optional[str] = None,
        institution_user_id_in: typing.Optional[str] = None,
        refresh_rate: typing.Optional[str] = None,
        status: typing.Optional[str] = None,
        status_in: typing.Optional[str] = None,
    ) -> PaginatedResponseLink:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
            params={
                "page": page,
                "page_size": page_size,
                "omit": omit,
                "fields": fields,
                "access_mode": access_mode,
                "created_at": created_at,
                "created_at__gt": created_at_gt,
                "created_at__gte": created_at_gte,
                "created_at__lt": created_at_lt,
                "created_at__lte": created_at_lte,
                "created_at__range": created_at_range,
                "created_by__not_in": created_by_not_in,
                "external_id": external_id,
                "external_id__in": external_id_in,
                "id": id,
                "id__in": id_in,
                "institution": institution,
                "institution__in": institution_in,
                "institution_user_id": institution_user_id,
                "institution_user_id__in": institution_user_id_in,
                "refresh_rate": refresh_rate,
                "status": status,
                "status__in": status_in,
            },
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedResponseLink, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def register_link(
        self,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        institution: str,
        username: str,
        password: typing.Optional[str] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        username_2: typing.Optional[str] = OMIT,
        username_3: typing.Optional[str] = OMIT,
        password_2: typing.Optional[str] = OMIT,
        token: typing.Optional[str] = OMIT,
        access_mode: typing.Optional[EnumLinkAccessModeRequest] = OMIT,
        fetch_historical: typing.Optional[bool] = OMIT,
        credentials_storage: typing.Optional[str] = OMIT,
        username_type: typing.Optional[str] = OMIT,
        certificate: typing.Optional[str] = OMIT,
        private_key: typing.Optional[str] = OMIT,
    ) -> Link:
        _request: typing.Dict[str, typing.Any] = {"institution": institution, "username": username}
        if password is not OMIT:
            _request["password"] = password
        if external_id is not OMIT:
            _request["external_id"] = external_id
        if username_2 is not OMIT:
            _request["username2"] = username_2
        if username_3 is not OMIT:
            _request["username3"] = username_3
        if password_2 is not OMIT:
            _request["password2"] = password_2
        if token is not OMIT:
            _request["token"] = token
        if access_mode is not OMIT:
            _request["access_mode"] = access_mode
        if fetch_historical is not OMIT:
            _request["fetch_historical"] = fetch_historical
        if credentials_storage is not OMIT:
            _request["credentials_storage"] = credentials_storage
        if username_type is not OMIT:
            _request["username_type"] = username_type
        if certificate is not OMIT:
            _request["certificate"] = certificate
        if private_key is not OMIT:
            _request["private_key"] = private_key
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
            params={"omit": omit, "fields": fields},
            json=jsonable_encoder(_request),
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch_links(
        self,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        request: PatchBodyWithoutSaveData,
    ) -> Link:
        _response = httpx.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
            params={"omit": omit, "fields": fields},
            json=jsonable_encoder(request),
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def detail_link(self, id: str, *, omit: typing.Optional[str] = None, fields: typing.Optional[str] = None) -> Link:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
            params={"omit": omit, "fields": fields},
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_link(
        self,
        id: str,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        password: str,
        password_2: typing.Optional[str] = OMIT,
        token: typing.Optional[str] = OMIT,
        username_type: typing.Optional[str] = OMIT,
        certificate: typing.Optional[str] = OMIT,
        private_key: typing.Optional[str] = OMIT,
    ) -> Link:
        _request: typing.Dict[str, typing.Any] = {"password": password}
        if password_2 is not OMIT:
            _request["password2"] = password_2
        if token is not OMIT:
            _request["token"] = token
        if username_type is not OMIT:
            _request["username_type"] = username_type
        if certificate is not OMIT:
            _request["certificate"] = certificate
        if private_key is not OMIT:
            _request["private_key"] = private_key
        _response = httpx.request(
            "PUT",
            urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
            params={"omit": omit, "fields": fields},
            json=jsonable_encoder(_request),
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def change_link_access_mode(
        self,
        id: str,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        access_mode: EnumLinkAccessModeRequest,
    ) -> Link:
        _response = httpx.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
            params={"omit": omit, "fields": fields},
            json=jsonable_encoder({"access_mode": access_mode}),
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def destroy_link(self, id: str) -> None:
        _response = httpx.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
            auth=(self._secret_id, self._secret_password)
            if self._secret_id is not None and self._secret_password is not None
            else None,
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncLinksClient:
    def __init__(
        self, *, environment: BelvoEnvironment = BelvoEnvironment.PRODUCTION, secret_id: str, secret_password: str
    ):
        self._environment = environment
        self._secret_id = secret_id
        self._secret_password = secret_password

    async def list_links(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        access_mode: typing.Optional[str] = None,
        created_at: typing.Optional[str] = None,
        created_at_gt: typing.Optional[str] = None,
        created_at_gte: typing.Optional[str] = None,
        created_at_lt: typing.Optional[str] = None,
        created_at_lte: typing.Optional[str] = None,
        created_at_range: typing.Optional[str] = None,
        created_by_not_in: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        external_id_in: typing.Optional[str] = None,
        id: typing.Optional[str] = None,
        id_in: typing.Optional[str] = None,
        institution: typing.Optional[str] = None,
        institution_in: typing.Optional[str] = None,
        institution_user_id: typing.Optional[str] = None,
        institution_user_id_in: typing.Optional[str] = None,
        refresh_rate: typing.Optional[str] = None,
        status: typing.Optional[str] = None,
        status_in: typing.Optional[str] = None,
    ) -> PaginatedResponseLink:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
                params={
                    "page": page,
                    "page_size": page_size,
                    "omit": omit,
                    "fields": fields,
                    "access_mode": access_mode,
                    "created_at": created_at,
                    "created_at__gt": created_at_gt,
                    "created_at__gte": created_at_gte,
                    "created_at__lt": created_at_lt,
                    "created_at__lte": created_at_lte,
                    "created_at__range": created_at_range,
                    "created_by__not_in": created_by_not_in,
                    "external_id": external_id,
                    "external_id__in": external_id_in,
                    "id": id,
                    "id__in": id_in,
                    "institution": institution,
                    "institution__in": institution_in,
                    "institution_user_id": institution_user_id,
                    "institution_user_id__in": institution_user_id_in,
                    "refresh_rate": refresh_rate,
                    "status": status,
                    "status__in": status_in,
                },
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PaginatedResponseLink, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def register_link(
        self,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        institution: str,
        username: str,
        password: typing.Optional[str] = OMIT,
        external_id: typing.Optional[str] = OMIT,
        username_2: typing.Optional[str] = OMIT,
        username_3: typing.Optional[str] = OMIT,
        password_2: typing.Optional[str] = OMIT,
        token: typing.Optional[str] = OMIT,
        access_mode: typing.Optional[EnumLinkAccessModeRequest] = OMIT,
        fetch_historical: typing.Optional[bool] = OMIT,
        credentials_storage: typing.Optional[str] = OMIT,
        username_type: typing.Optional[str] = OMIT,
        certificate: typing.Optional[str] = OMIT,
        private_key: typing.Optional[str] = OMIT,
    ) -> Link:
        _request: typing.Dict[str, typing.Any] = {"institution": institution, "username": username}
        if password is not OMIT:
            _request["password"] = password
        if external_id is not OMIT:
            _request["external_id"] = external_id
        if username_2 is not OMIT:
            _request["username2"] = username_2
        if username_3 is not OMIT:
            _request["username3"] = username_3
        if password_2 is not OMIT:
            _request["password2"] = password_2
        if token is not OMIT:
            _request["token"] = token
        if access_mode is not OMIT:
            _request["access_mode"] = access_mode
        if fetch_historical is not OMIT:
            _request["fetch_historical"] = fetch_historical
        if credentials_storage is not OMIT:
            _request["credentials_storage"] = credentials_storage
        if username_type is not OMIT:
            _request["username_type"] = username_type
        if certificate is not OMIT:
            _request["certificate"] = certificate
        if private_key is not OMIT:
            _request["private_key"] = private_key
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
                params={"omit": omit, "fields": fields},
                json=jsonable_encoder(_request),
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch_links(
        self,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        request: PatchBodyWithoutSaveData,
    ) -> Link:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PATCH",
                urllib.parse.urljoin(f"{self._environment.value}/", "api/links"),
                params={"omit": omit, "fields": fields},
                json=jsonable_encoder(request),
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def detail_link(
        self, id: str, *, omit: typing.Optional[str] = None, fields: typing.Optional[str] = None
    ) -> Link:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
                params={"omit": omit, "fields": fields},
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_link(
        self,
        id: str,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        password: str,
        password_2: typing.Optional[str] = OMIT,
        token: typing.Optional[str] = OMIT,
        username_type: typing.Optional[str] = OMIT,
        certificate: typing.Optional[str] = OMIT,
        private_key: typing.Optional[str] = OMIT,
    ) -> Link:
        _request: typing.Dict[str, typing.Any] = {"password": password}
        if password_2 is not OMIT:
            _request["password2"] = password_2
        if token is not OMIT:
            _request["token"] = token
        if username_type is not OMIT:
            _request["username_type"] = username_type
        if certificate is not OMIT:
            _request["certificate"] = certificate
        if private_key is not OMIT:
            _request["private_key"] = private_key
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PUT",
                urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
                params={"omit": omit, "fields": fields},
                json=jsonable_encoder(_request),
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def change_link_access_mode(
        self,
        id: str,
        *,
        omit: typing.Optional[str] = None,
        fields: typing.Optional[str] = None,
        access_mode: EnumLinkAccessModeRequest,
    ) -> Link:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "PATCH",
                urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
                params={"omit": omit, "fields": fields},
                json=jsonable_encoder({"access_mode": access_mode}),
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Link, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(
                pydantic.parse_obj_as(typing.List[BadRequestErrorBodyItem], _response.json())  # type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        if _response.status_code == 428:
            raise PreconditionError(
                pydantic.parse_obj_as(typing.List[TokenRequiredResponse], _response.json())  # type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(typing.List[UnexpectedError], _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def destroy_link(self, id: str) -> None:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "DELETE",
                urllib.parse.urljoin(f"{self._environment.value}/", f"api/links/{id}"),
                auth=(self._secret_id, self._secret_password)
                if self._secret_id is not None and self._secret_password is not None
                else None,
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 401:
            raise UnauthorizedError(
                pydantic.parse_obj_as(typing.List[UnauthorizedErrorBody], _response.json())  # type: ignore
            )
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.List[NotFoundErrorBody], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
