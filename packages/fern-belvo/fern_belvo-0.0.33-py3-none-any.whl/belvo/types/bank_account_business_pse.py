# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .holder_business_response_pse import HolderBusinessResponsePse


class BankAccountBusinessPse(pydantic.BaseModel):
    id: str = pydantic.Field(description=("Belvo's unique ID for the current bank account.\n"))
    created_at: str = pydantic.Field(
        description=("The ISO-8601 timestamp of when the data point was first created in Belvo's database.\n")
    )
    created_by: str = pydantic.Field(description=("Belvo's unique ID for the user that created the bank account.\n"))
    customer: typing.Optional[str] = pydantic.Field(
        description=(
            "Belvo's unique ID for the customer associated with the bank account.\n"
            "For `BUSINESS` bank accounts, this field is `null`.\n"
        )
    )
    institution: typing.Optional[str] = pydantic.Field(
        description=(
            "Belvo's unique ID for the institution that the bank account is created in.\n"
            "For `BUSINESS` bank accounts that Belvo creates for organizations, this field is `null`.\n"
        )
    )
    number: str = pydantic.Field(description=("The bank account number of the payment beneficiary.\n"))
    holder: HolderBusinessResponsePse
    details: typing.Dict[str, typing.Any] = pydantic.Field(
        description=("For PSE, this field will return an empty object.\n")
    )
    metadata: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(
        description=(
            "Optional and customizable object where you can provide any additional key-value pairs for your internal purposes. For example, an internal reference number for the payment intent.\n"
            "\n"
            "⚠️ **Note**: You can only provide up to 50 keys (keys can have up to 50 characters each and each value can be up to 500 characters). We do not support nested objects, only ASCII values.\n"
        )
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        json_encoders = {dt.datetime: serialize_datetime}
