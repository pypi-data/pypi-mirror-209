# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .enum_investment_portfolio_instrument_type import EnumInvestmentPortfolioInstrumentType
from .investments_portfolio_instrument_fees import InvestmentsPortfolioInstrumentFees
from .investments_portfolio_instrument_interest_rate import InvestmentsPortfolioInstrumentInterestRate
from .investments_portfolio_instrument_public_id import InvestmentsPortfolioInstrumentPublicId
from .investments_portfolio_instrument_redemption_conditions import InvestmentsPortfolioInstrumentRedemptionConditions


class InvestmentsPortfolioInstrument(pydantic.BaseModel):
    id: typing.Optional[str] = pydantic.Field(description=("Belvo's unique ID for the current instrument.\n"))
    public_id: typing.Optional[typing.List[InvestmentsPortfolioInstrumentPublicId]] = pydantic.Field(
        description=("The public identifiers for the instrument.\n")
    )
    type: EnumInvestmentPortfolioInstrumentType
    subtype: typing.Optional[str] = pydantic.Field(
        description=("The subtype for the instrument, as given by the institution.\n")
    )
    name: str = pydantic.Field(description=("The name of the instrument, as given by the institution.\n"))
    currency: str = pydantic.Field(
        description=(
            "The currency of the instrument. For example:\n"
            "\n"
            "- ðŸ‡§ðŸ‡· BRL (Brazilian Real)\n"
            "- ðŸ‡¨ðŸ‡´ COP (Colombian Peso)\n"
            "- ðŸ‡²ðŸ‡½ MXN (Mexican Peso)\n"
            "- ðŸ‡ºðŸ‡¸ USD (US Dollar)\n"
            "\n"
            "\n"
            "Please note that other currencies other than in the list above may be returned.\n"
        )
    )
    price: typing.Optional[float] = pydantic.Field(description=("The current price of one share in the instrument.\n"))
    quantity: typing.Optional[float] = pydantic.Field(
        description=("The total amount of shares owned in the instrument.\n")
    )
    balance_gross: typing.Optional[float] = pydantic.Field(
        description=("The total gross value of the instrument (including taxes).\n")
    )
    balance_net: typing.Optional[float] = pydantic.Field(
        description=("The total net value of the instrument (excluding taxes).\n")
    )
    average_acquisition_price: typing.Optional[float] = pydantic.Field(
        description=("The average price of each share acquired in the instrument.\n")
    )
    profit: typing.Optional[float] = pydantic.Field(description=("The current profit earned in the instrument.\n"))
    open_date: typing.Optional[str] = pydantic.Field(
        description=("The start date of the instrument. Only applicable for instruments of type `bond` or `savings`.\n")
    )
    redemption_conditions: typing.Optional[
        typing.List[typing.Optional[InvestmentsPortfolioInstrumentRedemptionConditions]]
    ] = pydantic.Field(
        description=(
            "An array of conditions that apply to the instrument in order to retrieve the final value.\n"
            "\n"
            "For example, the due date, the liquidity date, the previdencia type, and so on.\n"
        )
    )
    fees: typing.Optional[typing.List[typing.Optional[InvestmentsPortfolioInstrumentFees]]] = pydantic.Field(
        description=("An array of fees that apply to the instrument.\n")
    )
    interest_rates: typing.Optional[
        typing.List[typing.Optional[InvestmentsPortfolioInstrumentInterestRate]]
    ] = pydantic.Field(description=("An array of interest rates that apply to the instrument.\n"))

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        json_encoders = {dt.datetime: serialize_datetime}
