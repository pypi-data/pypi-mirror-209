# -*- coding: utf-8 -*-

"""
swaggerpetstore

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from swaggerpetstore.api_helper import APIHelper
from swaggerpetstore.models.financial_transaction_status import FinancialTransactionStatus
from swaggerpetstore.models.fx_executed_rate import FXExecutedRate
from swaggerpetstore.models.identity import Identity
from swaggerpetstore.models.monetary_value import MonetaryValue
from swaggerpetstore.models.payout_details import PayoutDetails
from swaggerpetstore.models.statement_detail import StatementDetail
from swaggerpetstore.models.transaction_id import TransactionID
from swaggerpetstore.models.user_id import UserID
from swaggerpetstore.models.users_bank_id import UsersBankID


class FinancialTransaction(object):

    """Implementation of the 'FinancialTransaction' model.

    Minimum set of data that constitutes a financial transaction.

    Attributes:
        transaction_id (TransactionID): Transaction ID type which contains
            both the unique Earthport transaction ID and the merchant supplied
            transaction ID.
        timestamp (string): A timestamp of the transaction. A valid ISO 8601
            timestamp, such as YYYY-MM-DDThh:mm:ss.sssÂ±hh:mm.
        transaction_status (FinancialTransactionStatus): Additional important
            status information for specific transaction types.    | code  |
            description  | Meaning |  | ----  | -----------  | ------- |  |
            100   | Pending Processing | This is the initial state when
            Earthport receives your payment instruction. |  | 200   | In
            Process         | This means the payment is being processed by
            Earthport's payment platform. |  | 300   | With Partner Bank  |
            Earthport has sent the payment onto our partner bank and we are
            awaiting an ACK. |  | 400   | Payment Sent       | Earthport has
            sent the payment to the partner bank and has received an ACK.|  |
            500   | Rejected Payout    | A payment can be rejected when
            uploading to the partner bank's system or by Earthport's
            compliance team. |  | 600   | Returned Payout    | A returned
            payment is when Earthport processes the payment, sends on to our
            partner bank to be settled in the destination ACH but the
            beneficiary bank returns the payment. This could be becasue the
            bank account is closed.|  | 700   | Insufficient Merchant
            liquidity | If you (Earthport's client) is holding insufficient
            liquidity funding with Earthport, then payments will appear in
            this state. Earthport will not reject or fail the payments and
            will wait for you to provide funding before they can be processed.
            |  | 800   | Pending Cancellation            | A payment can be in
            this state, if you call the cancel payment API. |
        amount (MonetaryValue): Represents a monetary value containing a
            decimal amount value along with a currency code. The currency code
            is a three letter ISO 4217 code. E.g. GBP for British sterling
            pounds.
        movement_type (MoneyMovementTypeEnum): Specifies whether a money
            movement is a debit or credit.
        statement_details (list of StatementDetail): Set of key value pairs
            that provide additional details about a money movement.
        description (string): A reason or description or narrative as entered
            against the journal entry.
        transaction_type (string): TODO: type description here.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    _optionals = [
        'transaction_status',
        'statement_details',
        'description',
        'transaction_type',
    ]

    def __init__(self,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='Transaction'):
        """Constructor for the FinancialTransaction class"""

        # Initialize members of the class
        self.transaction_id = transaction_id 
        self.timestamp = timestamp 
        if transaction_status is not APIHelper.SKIP:
            self.transaction_status = transaction_status 
        self.amount = amount 
        self.movement_type = movement_type 
        if statement_details is not APIHelper.SKIP:
            self.statement_details = statement_details 
        if description is not APIHelper.SKIP:
            self.description = description 
        self.transaction_type = transaction_type 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        discriminators = {
            'PayoutTransaction': PayoutTransaction.from_dictionary,
            'UserDepositTransaction': UserDepositTransaction.from_dictionary,
            'RefundTransaction': RefundTransaction.from_dictionary,
            'MerchantLiquidityMovementTransaction': MerchantLiquidityMovementTransaction.from_dictionary,
            'LiquidityDepositTransaction': LiquidityDepositTransaction.from_dictionary
        }
        unboxer = discriminators.get(dictionary.get('transactionType'))

        # Delegate unboxing to another function if a discriminator
        # value for a child class is present.
        if unboxer:
            return unboxer(dictionary)

        # Extract variables from the dictionary

        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'Transaction'
        # Return an object of this model
        return cls(transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)


class PayoutTransaction(FinancialTransaction):

    """Implementation of the 'PayoutTransaction' model.

    A financial transaction representing a payout from an account held in the
    EPS system.
    NOTE: This class inherits from 'FinancialTransaction'.

    Attributes:
        users_bank_id (UsersBankID): This group consists of a collection of
            both the user ID group and beneficiary bank ID group. The 'userID'
            is a collection of user identifier types. The 'benBankID' is a
            collection of account identifier types. Both the 'userID' and
            'benBankID' fields are mandatory.
        payout_request_amount (MonetaryValue): Represents a monetary value
            containing a decimal amount value along with a currency code. The
            currency code is a three letter ISO 4217 code. E.g. GBP for
            British sterling pounds.
        settlement_instruction_amount (MonetaryValue): Represents a monetary
            value containing a decimal amount value along with a currency
            code. The currency code is a three letter ISO 4217 code. E.g. GBP
            for British sterling pounds.
        beneficiary_statement_narrative (string): Narrative text to be
            displayed on the beneficiary bank accounts statement, where the
            banking network supports this.
        payout_details (list of PayoutDetails): Allows additional data to be
            supplied with a payout. Refer to documentation for valid keys.
        expected_settlement_date (string): Indicative date when the payout
            instruction is expected to be settled to the bank. This is
            calculated taking into account such things as acceptedDate, the
            settlement agreement cut-off time and period, etc. It currently
            does not take into account individual countries' banking
            calendars.
        beneficiary_bank_country (string): Country of the target beneficiary
            bank.
        beneficiary_bank_currency (string): Currency of the target beneficiary
            bank account.
        debit_value_date (string): Timestamp when the payout instruction was
            accepted by the Earthport payment system.
        payer_identity (Identity): Represents the identity of an individual or
            legal entity. You must specify one of either an individual
            identity or legal entity identity or unstructured identity.
        payer_created_date (string): Date payer was created.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "users_bank_id": 'usersBankID',
        "payout_request_amount": 'payoutRequestAmount',
        "settlement_instruction_amount": 'settlementInstructionAmount',
        "beneficiary_statement_narrative": 'beneficiaryStatementNarrative',
        "expected_settlement_date": 'expectedSettlementDate',
        "beneficiary_bank_country": 'beneficiaryBankCountry',
        "beneficiary_bank_currency": 'beneficiaryBankCurrency',
        "debit_value_date": 'debitValueDate',
        "payer_identity": 'payerIdentity',
        "payer_created_date": 'payerCreatedDate',
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "payout_details": 'payoutDetails',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    _optionals = [
        'payout_details',
    ]
    _optionals.extend(FinancialTransaction._optionals)

    def __init__(self,
                 users_bank_id=None,
                 payout_request_amount=None,
                 settlement_instruction_amount=None,
                 beneficiary_statement_narrative=None,
                 expected_settlement_date=None,
                 beneficiary_bank_country=None,
                 beneficiary_bank_currency=None,
                 debit_value_date=None,
                 payer_identity=None,
                 payer_created_date=None,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 payout_details=APIHelper.SKIP,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='PayoutTransaction'):
        """Constructor for the PayoutTransaction class"""

        # Initialize members of the class
        self.users_bank_id = users_bank_id 
        self.payout_request_amount = payout_request_amount 
        self.settlement_instruction_amount = settlement_instruction_amount 
        self.beneficiary_statement_narrative = beneficiary_statement_narrative 
        if payout_details is not APIHelper.SKIP:
            self.payout_details = payout_details 
        self.expected_settlement_date = expected_settlement_date 
        self.beneficiary_bank_country = beneficiary_bank_country 
        self.beneficiary_bank_currency = beneficiary_bank_currency 
        self.debit_value_date = debit_value_date 
        self.payer_identity = payer_identity 
        self.payer_created_date = payer_created_date 

        # Call the constructor for the base class
        super(PayoutTransaction, self).__init__(transaction_id,
                                                timestamp,
                                                amount,
                                                movement_type,
                                                transaction_status,
                                                statement_details,
                                                description,
                                                transaction_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        users_bank_id = UsersBankID.from_dictionary(dictionary.get('usersBankID')) if dictionary.get('usersBankID') else None
        payout_request_amount = MonetaryValue.from_dictionary(dictionary.get('payoutRequestAmount')) if dictionary.get('payoutRequestAmount') else None
        settlement_instruction_amount = MonetaryValue.from_dictionary(dictionary.get('settlementInstructionAmount')) if dictionary.get('settlementInstructionAmount') else None
        beneficiary_statement_narrative = dictionary.get("beneficiaryStatementNarrative") if dictionary.get("beneficiaryStatementNarrative") else None
        expected_settlement_date = dictionary.get("expectedSettlementDate") if dictionary.get("expectedSettlementDate") else None
        beneficiary_bank_country = dictionary.get("beneficiaryBankCountry") if dictionary.get("beneficiaryBankCountry") else None
        beneficiary_bank_currency = dictionary.get("beneficiaryBankCurrency") if dictionary.get("beneficiaryBankCurrency") else None
        debit_value_date = dictionary.get("debitValueDate") if dictionary.get("debitValueDate") else None
        payer_identity = Identity.from_dictionary(dictionary.get('payerIdentity')) if dictionary.get('payerIdentity') else None
        payer_created_date = dictionary.get("payerCreatedDate") if dictionary.get("payerCreatedDate") else None
        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        payout_details = None
        if dictionary.get('payoutDetails') is not None:
            payout_details = [PayoutDetails.from_dictionary(x) for x in dictionary.get('payoutDetails')]
        else:
            payout_details = APIHelper.SKIP
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'PayoutTransaction'
        # Return an object of this model
        return cls(users_bank_id,
                   payout_request_amount,
                   settlement_instruction_amount,
                   beneficiary_statement_narrative,
                   expected_settlement_date,
                   beneficiary_bank_country,
                   beneficiary_bank_currency,
                   debit_value_date,
                   payer_identity,
                   payer_created_date,
                   transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   payout_details,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)


class UserDepositTransaction(FinancialTransaction):

    """Implementation of the 'UserDepositTransaction' model.

    A financial transaction representing money paid into a merchant's account
    by a user.
    NOTE: This class inherits from 'FinancialTransaction'.

    Attributes:
        user_id (UserID): This group consists of all possible user identifier
            types. The 'epUserID' field is the Earthport generated unique
            identifier for a User and is the equivalent of a Virtual Account
            Number (VAN). The 'merchantUserID' is a merchant specified
            identifier for the User. The 'epUserID', 'merchantUserID' or both
            'epUserID' and 'merchantUserID' can be supplied. A mapping will be
            performed to retrieve the merchant user ID from the supplied EP
            user ID and vice versa. If both the 'epUserID' and
            'merchantUserID' are supplied, a check will be performed to ensure
            that the two are mapped. If the two provided fields are not
            mapped, then a validation error code will be returned. At least
            one of the fields must be populated.
        deposit_date (string): Valid ISO 8601 date format YYYY-MM-DD.
        deposit_reference (string): A Merchant User Deposit Reference.
        deposit_country (string): Valid supported ISO 3166 2-character country
            code.
        amount_deposited_by_user (MonetaryValue): Represents a monetary value
            containing a decimal amount value along with a currency code. The
            currency code is a three letter ISO 4217 code. E.g. GBP for
            British sterling pounds.
        amount_deposited_to_merchant (MonetaryValue): Represents a monetary
            value containing a decimal amount value along with a currency
            code. The currency code is a three letter ISO 4217 code. E.g. GBP
            for British sterling pounds.
        fx_executed_detail (FXExecutedRate): Holds details of an executed FX
            conversion that has occured as part of a financial transaction.
            The FX that occured was from the sellCurrency to the buyCurrency
            at a particular rate. The rate may have been requested via an FX
            Quote (fxTicketID). An FX conversion fee may have been applied to
            certain transaction types.
        unapplied_reason (string): The reason the deposit was not applied to
            the merchant's virtual account.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "user_id": 'userID',
        "deposit_date": 'depositDate',
        "deposit_country": 'depositCountry',
        "amount_deposited_by_user": 'amountDepositedByUser',
        "amount_deposited_to_merchant": 'amountDepositedToMerchant',
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "deposit_reference": 'depositReference',
        "fx_executed_detail": 'fxExecutedDetail',
        "unapplied_reason": 'unappliedReason',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    _optionals = [
        'deposit_reference',
        'fx_executed_detail',
        'unapplied_reason',
    ]
    _optionals.extend(FinancialTransaction._optionals)

    def __init__(self,
                 user_id=None,
                 deposit_date=None,
                 deposit_country=None,
                 amount_deposited_by_user=None,
                 amount_deposited_to_merchant=None,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 deposit_reference=APIHelper.SKIP,
                 fx_executed_detail=APIHelper.SKIP,
                 unapplied_reason=APIHelper.SKIP,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='UserDepositTransaction'):
        """Constructor for the UserDepositTransaction class"""

        # Initialize members of the class
        self.user_id = user_id 
        self.deposit_date = deposit_date 
        if deposit_reference is not APIHelper.SKIP:
            self.deposit_reference = deposit_reference 
        self.deposit_country = deposit_country 
        self.amount_deposited_by_user = amount_deposited_by_user 
        self.amount_deposited_to_merchant = amount_deposited_to_merchant 
        if fx_executed_detail is not APIHelper.SKIP:
            self.fx_executed_detail = fx_executed_detail 
        if unapplied_reason is not APIHelper.SKIP:
            self.unapplied_reason = unapplied_reason 

        # Call the constructor for the base class
        super(UserDepositTransaction, self).__init__(transaction_id,
                                                     timestamp,
                                                     amount,
                                                     movement_type,
                                                     transaction_status,
                                                     statement_details,
                                                     description,
                                                     transaction_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        user_id = UserID.from_dictionary(dictionary.get('userID')) if dictionary.get('userID') else None
        deposit_date = dictionary.get("depositDate") if dictionary.get("depositDate") else None
        deposit_country = dictionary.get("depositCountry") if dictionary.get("depositCountry") else None
        amount_deposited_by_user = MonetaryValue.from_dictionary(dictionary.get('amountDepositedByUser')) if dictionary.get('amountDepositedByUser') else None
        amount_deposited_to_merchant = MonetaryValue.from_dictionary(dictionary.get('amountDepositedToMerchant')) if dictionary.get('amountDepositedToMerchant') else None
        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        deposit_reference = dictionary.get("depositReference") if dictionary.get("depositReference") else APIHelper.SKIP
        fx_executed_detail = FXExecutedRate.from_dictionary(dictionary.get('fxExecutedDetail')) if 'fxExecutedDetail' in dictionary.keys() else APIHelper.SKIP
        unapplied_reason = dictionary.get("unappliedReason") if dictionary.get("unappliedReason") else APIHelper.SKIP
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'UserDepositTransaction'
        # Return an object of this model
        return cls(user_id,
                   deposit_date,
                   deposit_country,
                   amount_deposited_by_user,
                   amount_deposited_to_merchant,
                   transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   deposit_reference,
                   fx_executed_detail,
                   unapplied_reason,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)


class RefundTransaction(FinancialTransaction):

    """Implementation of the 'RefundTransaction' model.

    TODO: type model description here.
    NOTE: This class inherits from 'FinancialTransaction'.

    Attributes:
        user_id (UserID): This group consists of all possible user identifier
            types. The 'epUserID' field is the Earthport generated unique
            identifier for a User and is the equivalent of a Virtual Account
            Number (VAN). The 'merchantUserID' is a merchant specified
            identifier for the User. The 'epUserID', 'merchantUserID' or both
            'epUserID' and 'merchantUserID' can be supplied. A mapping will be
            performed to retrieve the merchant user ID from the supplied EP
            user ID and vice versa. If both the 'epUserID' and
            'merchantUserID' are supplied, a check will be performed to ensure
            that the two are mapped. If the two provided fields are not
            mapped, then a validation error code will be returned. At least
            one of the fields must be populated.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "user_id": 'userID',
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    def __init__(self,
                 user_id=None,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='RefundTransaction'):
        """Constructor for the RefundTransaction class"""

        # Initialize members of the class
        self.user_id = user_id 

        # Call the constructor for the base class
        super(RefundTransaction, self).__init__(transaction_id,
                                                timestamp,
                                                amount,
                                                movement_type,
                                                transaction_status,
                                                statement_details,
                                                description,
                                                transaction_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        user_id = UserID.from_dictionary(dictionary.get('userID')) if dictionary.get('userID') else None
        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'RefundTransaction'
        # Return an object of this model
        return cls(user_id,
                   transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)


class MerchantLiquidityMovementTransaction(FinancialTransaction):

    """Implementation of the 'MerchantLiquidityMovementTransaction' model.

    A financial transaction representing movement of funds between a
    merchant's accounts held in the EPS system.
    NOTE: This class inherits from 'FinancialTransaction'.

    Attributes:
        fx_executed_detail (FXExecutedRate): Holds details of an executed FX
            conversion that has occured as part of a financial transaction.
            The FX that occured was from the sellCurrency to the buyCurrency
            at a particular rate. The rate may have been requested via an FX
            Quote (fxTicketID). An FX conversion fee may have been applied to
            certain transaction types.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "fx_executed_detail": 'fxExecutedDetail',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    _optionals = [
        'fx_executed_detail',
    ]
    _optionals.extend(FinancialTransaction._optionals)

    def __init__(self,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 fx_executed_detail=APIHelper.SKIP,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='MerchantLiquidityMovementTransaction'):
        """Constructor for the MerchantLiquidityMovementTransaction class"""

        # Initialize members of the class
        if fx_executed_detail is not APIHelper.SKIP:
            self.fx_executed_detail = fx_executed_detail 

        # Call the constructor for the base class
        super(MerchantLiquidityMovementTransaction, self).__init__(transaction_id,
                                                                   timestamp,
                                                                   amount,
                                                                   movement_type,
                                                                   transaction_status,
                                                                   statement_details,
                                                                   description,
                                                                   transaction_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        fx_executed_detail = FXExecutedRate.from_dictionary(dictionary.get('fxExecutedDetail')) if 'fxExecutedDetail' in dictionary.keys() else APIHelper.SKIP
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'MerchantLiquidityMovementTransaction'
        # Return an object of this model
        return cls(transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   fx_executed_detail,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)


class LiquidityDepositTransaction(FinancialTransaction):

    """Implementation of the 'LiquidityDepositTransaction' model.

    Financial transaction representing a deposit of liquidity (money) into a
    merchant account.
    NOTE: This class inherits from 'FinancialTransaction'.

    Attributes:
        amount_credited_to_merchant_account (MonetaryValue): Represents a
            monetary value containing a decimal amount value along with a
            currency code. The currency code is a three letter ISO 4217 code.
            E.g. GBP for British sterling pounds.
        amount_received_at_bank (MonetaryValue): Represents a monetary value
            containing a decimal amount value along with a currency code. The
            currency code is a three letter ISO 4217 code. E.g. GBP for
            British sterling pounds.
        deposit_country (string): Valid supported ISO 3166 2-character country
            code. This represents the Country of liquidity deposit.
        deposit_date (string): Valid ISO 8601 date format YYYY-MM-DD. This
            represents the date of liquidity deposit.
        deposit_reference (string): A Merchant User Deposit Reference.
        fx_executed_detail (FXExecutedRate): Holds details of an executed FX
            conversion that has occured as part of a financial transaction.
            The FX that occured was from the sellCurrency to the buyCurrency
            at a particular rate. The rate may have been requested via an FX
            Quote (fxTicketID). An FX conversion fee may have been applied to
            certain transaction types.
        unapplied_reason (string): The reason the deposit was not applied to
            the merchant's virtual account.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "amount_credited_to_merchant_account": 'amountCreditedToMerchantAccount',
        "amount_received_at_bank": 'amountReceivedAtBank',
        "deposit_country": 'depositCountry',
        "deposit_date": 'depositDate',
        "transaction_id": 'transactionID',
        "timestamp": 'timestamp',
        "amount": 'amount',
        "movement_type": 'movementType',
        "deposit_reference": 'depositReference',
        "fx_executed_detail": 'fxExecutedDetail',
        "unapplied_reason": 'unappliedReason',
        "transaction_status": 'transactionStatus',
        "statement_details": 'statementDetails',
        "description": 'description',
        "transaction_type": 'transactionType'
    }

    _optionals = [
        'deposit_reference',
        'fx_executed_detail',
        'unapplied_reason',
    ]
    _optionals.extend(FinancialTransaction._optionals)

    def __init__(self,
                 amount_credited_to_merchant_account=None,
                 amount_received_at_bank=None,
                 deposit_country=None,
                 deposit_date=None,
                 transaction_id=None,
                 timestamp=None,
                 amount=None,
                 movement_type=None,
                 deposit_reference=APIHelper.SKIP,
                 fx_executed_detail=APIHelper.SKIP,
                 unapplied_reason=APIHelper.SKIP,
                 transaction_status=APIHelper.SKIP,
                 statement_details=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 transaction_type='LiquidityDepositTransaction'):
        """Constructor for the LiquidityDepositTransaction class"""

        # Initialize members of the class
        self.amount_credited_to_merchant_account = amount_credited_to_merchant_account 
        self.amount_received_at_bank = amount_received_at_bank 
        self.deposit_country = deposit_country 
        self.deposit_date = deposit_date 
        if deposit_reference is not APIHelper.SKIP:
            self.deposit_reference = deposit_reference 
        if fx_executed_detail is not APIHelper.SKIP:
            self.fx_executed_detail = fx_executed_detail 
        if unapplied_reason is not APIHelper.SKIP:
            self.unapplied_reason = unapplied_reason 

        # Call the constructor for the base class
        super(LiquidityDepositTransaction, self).__init__(transaction_id,
                                                          timestamp,
                                                          amount,
                                                          movement_type,
                                                          transaction_status,
                                                          statement_details,
                                                          description,
                                                          transaction_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if dictionary is None:
            return None

        # Extract variables from the dictionary

        amount_credited_to_merchant_account = MonetaryValue.from_dictionary(dictionary.get('amountCreditedToMerchantAccount')) if dictionary.get('amountCreditedToMerchantAccount') else None
        amount_received_at_bank = MonetaryValue.from_dictionary(dictionary.get('amountReceivedAtBank')) if dictionary.get('amountReceivedAtBank') else None
        deposit_country = dictionary.get("depositCountry") if dictionary.get("depositCountry") else None
        deposit_date = dictionary.get("depositDate") if dictionary.get("depositDate") else None
        transaction_id = TransactionID.from_dictionary(dictionary.get('transactionID')) if dictionary.get('transactionID') else None
        timestamp = dictionary.get("timestamp") if dictionary.get("timestamp") else None
        amount = MonetaryValue.from_dictionary(dictionary.get('amount')) if dictionary.get('amount') else None
        movement_type = dictionary.get("movementType") if dictionary.get("movementType") else None
        deposit_reference = dictionary.get("depositReference") if dictionary.get("depositReference") else APIHelper.SKIP
        fx_executed_detail = FXExecutedRate.from_dictionary(dictionary.get('fxExecutedDetail')) if 'fxExecutedDetail' in dictionary.keys() else APIHelper.SKIP
        unapplied_reason = dictionary.get("unappliedReason") if dictionary.get("unappliedReason") else APIHelper.SKIP
        transaction_status = FinancialTransactionStatus.from_dictionary(dictionary.get('transactionStatus')) if 'transactionStatus' in dictionary.keys() else APIHelper.SKIP
        statement_details = None
        if dictionary.get('statementDetails') is not None:
            statement_details = [StatementDetail.from_dictionary(x) for x in dictionary.get('statementDetails')]
        else:
            statement_details = APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        transaction_type = dictionary.get("transactionType") if dictionary.get("transactionType") else 'LiquidityDepositTransaction'
        # Return an object of this model
        return cls(amount_credited_to_merchant_account,
                   amount_received_at_bank,
                   deposit_country,
                   deposit_date,
                   transaction_id,
                   timestamp,
                   amount,
                   movement_type,
                   deposit_reference,
                   fx_executed_detail,
                   unapplied_reason,
                   transaction_status,
                   statement_details,
                   description,
                   transaction_type)
